var tipuesearch = {"pages":[{"title":"Introduction to network devices","text":"Repeater Pracuje na vrstvě 1 - fyzická vrstva (physical layer) Repeater je služebně nejstarší síťový prvek. V historii se v síťařině používal ikabely, ve kterých se signál se vzdáleností značně zeslaboval. Když jsme tedy chtěli zachovat sílu signálu (informace) na větší vzdálenosti, tak jsme museli po určité vzdálenosti signál zesílit. Toho se docílilo pomocí tzv. REPEATERŮ . Signál, který přišel do repeateru v něm byl pouze zesílen a poslán dále. Repeater vůbec neřeší jaký signál nebo informace je mu poslána pouze je zesílí. Repeatery si můžete také představit jako čerpadla vody a kabely mezi repeatery jako hadice, které dopravují vodu k požáru. Čím dále jste od čerpadla tím menší máte tlak. Pokud potřebujete dopravit vodu na velkou vzdálenost a zachovat hasební tlak musíte do hadicové trasy přidat další čerpadla, která tlak vody zase zesílí. HUB Pracuje na vrstvě 1 - fyzická vrstva (physical layer) Hub není nic jiného než multi repeater. Tedy dokáže zesílit signál z více vstupů na více výstupů. Opět u něj platí to co u repeaterů, že pouze zesiluje signály. Nijak je nevyhodnocuje ani jim nerozumí. Bridge Pracuje na vrstvě 2 - linková vrstva (data link layer) Jedná se o zařízení, které funguje jak switch, ovšem chytré přeposílání signálu na základě protokolů a portů dělá pomocí softwaru. Je tedy daleko pomalejší než switch, který tento úkol řeší na úrovni hardwaru. Switch (Přepínač) Pracuje na vrstvě 2 - linková vrstva (data link layer) Ukládá MAC adresy zařízení na příslušné číslo portu, na kterém je zařízení ve switch připojen. Switch tedy vykonává rozhodovací proces na základě MAC adres. Jednoduch& mspojením MAC adresy s číslem portu v CAM Table. Jedná se o takovou křižovatku síťového provozu na lokální úrovni, tedy spravuje pouze provoz na síti Local Area Network ( LAN ). Jinými slovy řídí síťový provoz pouze mezi zařízeními, které jsou připojeny na jednu stejnou síť. Toto není úplně správné protože exituje i tzv. VLAN tedy virtual local area network a switch je schopen propojit i dvě různé lokální sítě. Switch se chytře snaží signál přeposílat dle jeho parametrů. Dokáže vyhodnotit, na jaký port a MAC adresu je signál posílán. Díky těchto informací je schopen efektivně řídit komunikaci, vyhodnotit jak bude nejefektivnější signál poslat, aby nedocházelo ke střetům a zpomalení síťového provozu. Switch posílá signál na správný port, čímž komunikaci zefektivňuje. Logika přeposílání signálu je řešena na úrovni hardwaru pomocí chytrých obvodů ASICs (Application Specific Integrated Circuits). Switch je schopen se učit na základě toho, že ví kde jsou síťová zařízení, kde jsou jejich MAC adresy v síti. Switch zkoumá tzv. header od zasíláného požadavku, kde vyčte informaci o MAC adrese. Tuto informaci si dynamicky ukládá do tzv. CAM table, což je tabulka, která je vyplněná MAC adresama, které se switch naučil, díky toho ví, kam rychle poslat MAC adresu s kterou se už jednou setkal. Tyto MAC adresy si ale swithc neukládá do nekončna, každá MAC adresa je doplněna tzv. parametrem TTL (time to live), tento parametr udává, jak dlouho má být MAC adresa ve CAM table uložena a když je tato doba překročena MAC adresa se z této tabulky smaže. K mazání musí docházet protože paměť na ukládání MAC adres není nekonečná. Kromě TTL se také ukládá konrétní číslo interface switche ke konrétní MAC adrese. Zdrojová MAC adresa Celý proces vypadá asi takto, požadavek na zaslání informace přijde do switche. Ten se podívá do Headers (hlavičky) požadavku, tam vyčte MAC adresu zdroje informace (tedy unikátní adresu síťového zařízení, které požadavek posílá). Tuto MAC adresu porovná s adresami ve své tabulce, pokud tam není, tak ji přidá s číslem interface a TTL . Pokud už v tabulce MAC adresa je uložena, tak aktualizuje TTL . Pokud se připojila MAC adresa na jiné číslo interface, tak aktualizuje číslo interface. Cílová MAC adresa Tzv. forwarding Z hlaviček opět přečte switch destination MAC address. Podívá se do CAM table, pokud tam je posílá požadavek na interface spojen s touto MAC adresou. Pokud MAC adresa v CAM table není zašle požadavek dále přes všechny své interface. Switch se také hodí pokud potřebuje příchozí signál rozdělit, tedy máme jeden vstup a potřebujeme je rozdělit na dalších 5 výstupů. Dá se tedy říct, že je to takový chytrý multi rozbočovač. Funguje tedy i jako klasická roztrojka, kterou máme doma a zvyšujeme pomocí ní počet výstupů ze zásuvky 240 V. Switche obsahují většinou různé množství portů. Počet portů se pohybuje nejčastěji 5, 8, 16, 24, 48. Rychlosti switchů jsou 10, 100, 1000 Mb/s. Switche pracují na tzv. linkové vrstvě neberou tedy v potaz nějaká práva apod. To znamená že bezpečnost se v nich neřeší. Ta se řeší až na vyšších vrstvách nebo na úrovni topologie sítě. Switche se nejčastěji používají na rozšíření kabelové počítačové sítě (ethernet) Router Pracuje na vrstvě 3 - síťová vrstva (Network layer) Na rozdíl od Switche, Router vyhodnocuje IP adresy a na základě její hodnoty vyhodnocuje zda je nutné požadavek poslat do další sítě či nikoliv. Informace o IP adresách si router neukládá. Místo toho si ukládá informace o sítích do Routing Table, tedy do routing table si ukládá IP adresu sítě (Network portion) a Network mask. Router používá dvě interfaces: Serial interface - používá PPP Ethernet interface - používá MAC adresy PC_1, které chce poslat request na PC_2, které je na jiné síti, tak dochází k přwnosu informací následovně. PC_1 vyhodnotí zda IP adresa kterou hledáme je na stejné síti či nikoliv. Toho docílí pomocí AND . Kde kontroluje Network ID vlastní sítě a masky s cílovou IP adresou. Pokud vyhodnotí, že IP adresa není na stejné síti doplní požadavek nsáledovně - Layer 2 vyplní pomocí své MAC adresy jako Source address a destination address vyplni pomocí broadcast MAC adresy FF : FF : FF : FF : FF : FF . To se zašle na všechny zařízení v lokální síti. Na ni se najde IP adresa default gateway, což je náš router a ARP protokolem vrátí zpět svou MAC adresu. PC_1 si uloží do ARP cache dvojici IP adresu default gateway s MAC adresou našeho routeru. Spojuje dvě různé sítě většinou se bude jednat a propojení mezi sítí Local Area Network ( LAN - lokální síť) a Wide Area Network ( WAN - Internet). Routuje IP adresy mezi různými sítěmi. Modem Access Point Access point nám vytvoří novou wireless local area network ( WLAN ). Pro představu router který máte doma je schopen vytvořit WLAN . Dosah této bezdrátové sítě je ale omezený výkonem, jak na vysílači, tak na příjímači. K zvětšení rozsahu stávající bezdrátové sítě můžete použít tzv. range extender vysvětlen níže. Nebo vytvořit úplně nový zdroj bezdrátové sítě pomocí acces pointu. Access point je zapojen kabelem do routeru, switche nebo hubu a vytváří nový zdroj nové bezdrátové sítě. Range extender Wireless LAN controller If we have to manage and configure many access points. It is more efficient to manage them via Wireless LAN controller. But there is a problem Wireless LAN controller has not so many ports so if we have really a lot of access points we have to connect them to switch which is suitable for connection a very big number of devices and consequently switch is connected to Wireless LAN controller. Firewall (Hardware) Dnes máme hardwarové firewally nové generace, které jsou vybaveny systémy jako Intrusion Detection System ( IDS ) a Intrusion Prevention System ( IPS ). IDS , detekuje útok a upozorní na něj něco jako když máte doma psa, který Vás svým štěkotem upozorní, že máte doma zloděje, ale už ho nezastaví. Nejsou přímo v síťovém provozu. Dělá si kopie síťového provozu. IPS útok detekuje a zároveň zablokuje, prevent the attack. Je přím osoučástí síťového provozu a provoz proudí přímo přes něj.","tags":"Networks","url":"https://nappex.github.io/myblog/basics-networks-devices","loc":"https://nappex.github.io/myblog/basics-networks-devices"},{"title":"Jak vybrat monitor ?","text":"Úvod Pro správný výběr monitoru je nutná dobrá znalost jednotlivých parametrů, které uvádějí výrobci u svých produktů. Dále si také musíte uvědomit: K čemu budete monitor používat: hraní her, kancelářské práci, k programování nebo k vytváření grafiky Jak často chcete monitor používat: příležitostně (několikrát za měsíc) každý den 8h Používané technologie flickr free filtr modrého světla Pokud u monitoru budeme trávit většinu svého dne, tak stojí za to koupit kvalitní monitor. Monitory vyzařují tzv. modré světlo, které není pro naše oči zdravé a může způsobovat až problémy s nespavostí. Dalším problémem je problikávání crystalů u LCD obrazovek kvůli její životnosti. Naše podvědomí to nevnímá ale naše oči ano a velice je to namáhá. Výrobci si tento problém uvědomují a snaží se negativní aspekty obrazovek na naše oči eliminovat pomocí různých technologií jako flicker-free , filter modrého světla eliminovat. Pěkný článek o této problematice je zde . Software f.lux I když si koupíte monitor, který nabízí filtr modrého světla musíte si tento filtr manuálně zapínat. Abyste si nemuseli neustále manuálně zapínat a vypínat filtr modrého světla, což je otrava, existuje pro tento úkol aplikace f.lux , v které si vše nastavíte automaticky. f.lux makes the color of your computer's display adapt to the time of day, warm at night and like sunlight during the day. f.lux makes your computer screen look like the room you're in, all the time. When the sun sets, it makes your computer look like your indoor lights. In the morning, it makes things look like sunlight again. Cena Níže uvedené informace berte pouze jako můj laický názor, který jsem si utvořil po diskuzi s lidmi, kteří tomu rozumí lépe než já. Samozřejmě berte na zřetel, že ne každý monitor, který je drahý je kvalitní a naopak. Bohužel nelze hodnotit pouze na základě ceny. Pokud chcete nadupadný monitor, tak si budete muset připlatit, kvalitní produkt, za kterým stojí dlouhý a náročný vývoj něco stojí. Orientovat se jen podle ceny není šťastné rozhodnutí, můžete klidně koupit předražený šmejd nebo nepovedený model vyhnaný marketingem. do 5000 CZK , nejzákladnější monitory, dají se sehnat i povedené monitory nicméně je to ta nejnižší cenová kategorie a tomu odpovídají funkce, provedení a horší pozorovací úhly 5 - 10k CZK , zde už se najdou slušné monitory nad 10k CZK , zde už začínají velmi dobré monitory Jas Je vždy uveden jako maximální jas. Jas je jedna z fotometrických veličin, definovaná jako měrná veličina svítivosti. wikipedie-cs U monitorů naleznete jako standard 250 cd/m2. Jedná se o hodnotu, která u dává jak moc je možné monitor zesvětlit. Zesvětlení monitoru je ětšinou nutné pokud máte monitor na slunečnějším místě. Pokud máte monitor umístěný na slunném místě doporučuji si pořídit monitor s maximálním jasem alespoň 300 cd/m2. Z hlediska zdraví očí je lepší mít jas nastaven na co nejmenší hodnotu, ale zároveň tak, aby jste dobře viděli na věci na monitoru. Neměli byste se nikdy dívat do ostrého světla. Frekvence Tímto parametrem se u monitorů myslí tzv. obnovovací frekvence . Obnovovací frekvence udává maximální počet různých snímků, které dokáže monitor za jednu sekundu zobrazit, rozhoduje tedy o plynulosti obrazu. Standard u většiny monitorů je 60 Hz. Frekvence 60 Hz se bere také jako minimální doporučená hodnota. Dá se asi říct, že čím plynulejší obraz budeme mít, tím to pro naše oči bude příjemnější a budou se méně unavovat. Ovšem musíme si dát pozot na to, aby i náš hardware počítače byl schopen takovou frekvenci dodávat. Tedy můžeme si koupit monitor, který bude schopen zvládat obnovovací frekvenci 144 Hz, ale náš počítač nikoliv, zaplatíme si tedy za to co ani nevyužijeme…. Vyšší frekvence (120, 144 atd) poznáte, kromě her, i třeba při scrollování a určitě to očím nevadí, spíš naopak. Pokud by jste se pro to rozhodli, tak pozor, abys měli (třeba na notebooku) výstup, který to zvládne ! Jako příklad mohu uvést svůj problém. Jako zdroj obrazu mám MacBook Air early 2015, kdybych si tedy koupil například monitor s rozlišením 4K a obnovovací frekvencí 144Hz, tak ji nikdy nevyužiji naplno, protože podpora mého hardwaru pro 4K rozlišení s takovou obnovovací frekvence není ideální. Tedy je nutno si zkontrolovat všechny vstupy a výstupy obrazu, aby byli vzájemně kompatibilní a to i co se týká výkonu. Budu se tomuto dále věnovat v další kapitole vstupy, výstupy a konektory. Pozor Vysoká obnovovací frekvence bývá někdy popdorována jen přes jeden z mnoha dostupných portů na monitoru. Zkontrolujte si tedy zda Vámi požadovaná frekvence je na vstupu, který hodláte používat. Většinou to bývá Display port, který podporuje vysoké frekvence. Je možno zakoupit redukce z HDMI na DP cena je cca 1000 Kč, protože je v tom aktivní elektronika, opačně to neplatí a není problém. Dále se můžeme také setkat s termínem frekvence podsvícení . Tato frekvence není to samé jako obnovovací frekvence a dle mého názoru ani není uváděna mezi hlavními parametry. Nicméně je dobré o ní vědět z hlediska únavy očí. Touto problematikou se zabývá článek, na který jsem odkazoval už výše co je pwm . V krátkosti jde o to, že když měníte jas na monitoru, tak monitor nedisponuje všemi úrovněmi jasu, ale pouze 0 a 100% vše mezi tím se moduluje pomocí tzv pulzně šířkové modulace, jinými slovy monitor mění frekvenci obrazu. Monitor tedy bliká, my to nevnímáme, ale naše oči ano a velmi je to namáhá. To je důvod proč vznikly technologie jako Flicker free…. Vstupy, výstupy a konektory (kabely) Způsobů jak připojit monitor k našemu hardwaru je poměrně hodně. Dlouho jsem tuto část monitoru přehlížel z mé nevědomosti obsáhlosti a důležitosti tématu. Aby monitor fungoval dle našch představ musí být vstupy a výstupy v rovnováze. V opačném případě dostaneme pouze maximum toho nejhoršího členu, logicky. Můžeme si tedy koupit monitor za 20k CZK , který bude opravdová šajba mezi monitory, ale naše další komponenty nebudou s to mu dodávat obraz, který potřebuje pro své maximální využití, tak maximální výkon z něj nemáme jak dostat. Co sledovat: - obnovovací frekvence - rozlišení - přenosová rychlost - typ konektoru - podpora naší grafické karty Specifikace konektorů: existuje několik typů konektorů, ale to není vše. Každý typ má ještě několik svých verzí a každá verze je jinak výkonná. Zde můžete nalézt pěkný obrázek jak vypadaji jednotlivé konektory, kterými lze připojit Váš monitor. Celý článek HDMI vs DisplayPort vs DVI vs VGA vs USB -C – Which To Use? najdete zde Hlavní typy konektorů: - VGA - DVI - HDMI - Mini display port (Mini DP ) - Display port ( DP ) - USB -C VGA (Video Graphics Array) a DVI (digital Visual Interface) VGA Taková ta modrá koncovka se šroubkami. Je nejstarší technologie a slouží pouze pro analog. Byl vytvořen pro staré CRT monitory. S délkou kabelu obraz degraduje. DVI Bílá koncovka… Známý jako digitální video signál bez podpory audio. Vyráběl se ve třech verzích: - DVI -A, pouze analog - DVI -D, pouze digital - DVI -I, digital i analog Obě technologie jsou dnes už relativně zastaralé a využívají se spíše okrajově. V době FullHD, 4K apod. už nemají moc využití. Také hlavní nevýhodou těchto konektorů je fakt, že přes ně nemůžete posílat data. HDMI (High-Definition Multimedia Interface) Jedná se o technologii už z roku 2003 takže je poměrně stará, nicméně za ty roky prošla několika upgrady, takže dnešní HDMI je podstatně výkonnější než HDMI z roku 2003. Díky různým upgradům se HDMI na trhu objevuje v několika vrzích, které si vysvětíme níže. Je tedy nutné dávat si pozor jakou verzi si pořizujeme a co jaká verze podporuje. Tento konektor se těší velké oblibě a můžete jej nalézt opravdu všude od TV , monitorů až po herní konzole. Tato obliba je způsobena jeho velice univerzálním použitím. HDMI podporuje - multi-channel audio - ethernet data - superior color data - široké spektrum video formátů HDMI velikosti: - Typ A (standard) - Typ C (mini) - Typ D (micro) HDMI verze: HDMI 1.4 rychlost přenosu dat 10.2 Gb/s podpora 4K (4,096 x 2,160) s frekvencí 24Hz 4K (3,840 x 2,160) s frekvencí 30Hz, nebo 1080p s frekvencí 120Hz HDMI 2.0 rychlost přenosu dat 18 Gb/s 4K s frekvencí 60Hz HDMI 2.0a a 2.0b navíc podpora HDR (High Dynamic Range - rošiřuje rozsah barev, kterých si všimnete zejména při světlých nebo tmavých obrazech) HDMI 2.1 rychlost přenosu dat 48 Gb/s podpora Variabilní obnovovací frekvence ( VRR ), neboli dynamická změna obnovovací frekvence například v rozsahu 30 - 144 Hz. Není tak potřeba dále využívat technologie jako Nvidia's G-Sync a AMD 's FreeSync enhanced Audio Return Channel (eARC) který dovoluje posílání Dolby Atmos a DTS :X audio z displeje do příjmače 10k rozlišení s frekvencí 120 Hz U všech typů HDMI je nutné si při koupi kabelu zkontrolovat, zda je schopen přenášet data maximální rychlostí, kterou monitor umožňuje. Ne vždy tomu tak je. Je doporučeno kupovat certifikované kabely od ověřených prodejců. Display port Digitální rozhraní navržené organizací VESA (Video Electronics Standards Association) Display port má dvě základní velikosti obě obsahují 20 pinů: - Standard - Mini Display port byl dlouho upřednostňován před HDMI například pro hraní her. Vše změnilo když se na trhu objevil HDMI 2.1, který svými technickými parametry display port předčil. Výhodou oproti HDMI můžou být upevňovací nožičky díky, kterým je konetor lépe zapojen a nemůže se stát, že by nebyl pořádně zastrčen, což občas způsobuje problémy.. Další výhodou je podpora zapojení několika monitorů na jeden Display port - 2 monitory - 4 monitory - Existuje dokonce možnost řetězení až 6 displejů najednou, pokud váš grafický procesor umožňuje několik rozhraní DisplayPort Display port verze: DisplayPort 1.2 přenosová rychlost až 17.28 Gbps video rozlišení až 4K (3840 x 2190 pixels) s frekvencí 60 Hz, většina běžných 3D video formátů DisplayPort 1.3 přenosová rychlost až 25.92 Gbps video rozlišení 4K s frekvencí 120 Hz nebo 8K s frekvencí 30 Hz DisplayPort 1.4 přenosová rychlost až 25.92 Gbps video rozlišení až 8K s frekvencí 60 Hz HDR (High Dynamic Range) Display port 2.0 (rok 2020) přenosová rychlost až 77.4 Gbps video rozlišení 16K s HDR s frekvencí 60Hz 10K bez HDR s frekvencí 80Hz USB -C S tímto konektorem přišel na trh Apple. Pomocí tohoto konektoru můžeme přenášet video, audio, ethernet data a můžeme pomocí něj také nabíjet. Standard USB -C port offers 10 Gb/s bandwidth and 85 Watts charging capability Intel's Thunderbolt 3 port allows USB -C a whopping 40 Gb/s and a 100 Watts charge. Největší nevýhodou je asi nepodpora AMD 's FreeSync ani Nvidia's G-Sync. Na hraní her se tedy moc nehodí. Rozlišení Čím větší rozlišení tím detailnější obraz získáme. Což může být pro naše oči příjemnější jelikož nemusí tolik zaostřovat. Uvědomte si ale, že rozlišení je počet pixelů. Existují displeje se stejným počtem pixelů, ale jinou fyzickou velikostí, takže jsou pixely menší nebo větší. 4K se dělá od 6\" mobilů po TV o desítkách palců ! Seznam rozlišení s kterým se dnes můžete setkat. - 16K (15360 × 8640) - 10K (10240 × 4320) - 8K (7680 × 4320) - 5K (5120 x 2880) - 4K (3840 × 2160) monitor, (4096 x 2160) cinema - 2K (2560 x 1440) monitor, (2048 x 1080) cinema - Ultra HD ( UHD ) (3840 × 2160) - Quad HD ( QHD ) (2560 x 1440) - WUXGA (1920 x 1200) - FullHD (1920 x 1080) Dobrý je, že se blížíme rozlišení, kde už to nebude mít smysl zvyšovat, protože to prostě lidský oko nerozliší. Něco jako už je dávno s digitální hudbou, ani s nejlepší reprodukční technikou už nerozliší většina lidí vyšší vzorkovací frekvence atd. Většina lidí neslyší ani lepší ztrátovou kompresi ostatně. Pro TV je 8k skoro zbytečný a pro PC monitor asi tak akorát maximum, fajn jemný a fyzicky už prostě víc do strany koukat nechcete ani na zakřiveným, IMHO se tam zastavíme na dlouho. A něco jako 144 Hz bude asi taky smysluplný maximum pro běžný použití i hraní. Pixel per inch ( PPI ) PPI je docela důležitá hodnota, kterou Vám, ale málokterý prodejce u produktu uvede. Je to vlastně hustota pixelů na obrazovce, který se počítá z rozlišení s ohledem na jak velkém monitoru je použito. Čím více pixelů na inch tím je obraz jemnější a ostřejší a příjemnější pro oči. Obecně se nedoporučuje, aby hodnota byla pod 70 PPI - taková hodnota je nepoužitelná. Pro představu monitor o velikosti 25\" s rozlišením WUXGA (1920 x 1200) má hodnotu PPI rovnu 90. Nebo 27\" monitor s QHD (2560 x 1440) má hodnotu PPI 108,8. PPI si můžete sami spočítat, třeba v pythonu: Vzorec: \\(d_p = \\sqrt{W&#94;2 + H&#94;2}\\) \\(PPI = \\frac{d_p}{d_i}\\) W widtht resolution in pixels H height resolution in pixels \\(d_p\\) diagonal resolution in pixels \\(d_i\\) diagonal resolution in inches >>> ( 2560 ** 2 + 1440 ** 2 ) ** 0.5 / 27 >>> 108.78553926332337 Typ panelu Níže uvedené tři typy panelů jsou na trhu nejvíce zastoupeny: TN (Twisted Nematic) Nejstarší, má méně výrazné barvy a horší pozorovací úhly, pokud jste třeba programátor nebo mobilní developer, můžete používat monitor vertikálně a při tomto otočení se špatné pozorovaí úhly projeví. Naopak mají rychlou odezvu a vyšší obnovovací frekvenci. Hodí se na hraní her. Výhody: - rychlá odezva - vysoká obnovovací frekvence - cenově jsou nejpříznivější - dobré rozlišení odstínů šedé Nevýhody: - špatné barvy - špatné pozorovací úhly - prosvítání okrajů IPS (In-plain Switching) Mají obecně horší contrast ratio a horší odezvu. Naopak mají velmi pěkné barvy a velmi dobré pozorovací úhly 178°. Obecně se moc nehodí pro náročné hráče her jelikož, ti potřebují velmi dobrou obnovovací frekvenci a ten má lepší například TN panel. Nicméně i výrobci IPS se už dostávají na obnovovací frekvenci srovnatelnou s TN panely. Hodí se na editaci fotek a videa. Výhody: - velmi dobré a ostré barvy - dobré široké pozorovací úhly Nevýhody: - menší obnovovací frekvence než u TN - horší odezva - občas trpí prosvítajícím podsvětlením a nižší svítivostí - vyšší cena - nižší kontrast (1000:1) VA (Vertical Alignment) Je něco mezi IPS a TN . Mají obecně dobrý contrast ratio, ale na úkor response time. Hodí se na sledování videa. Výhody: - nejlepší conrast ratio (až 5000:1) - velmi dobré barevné hloubky - černá je opravdu černá - nulové prosvítání okolo okrajů Nevýhody: - pomalá odezva - špatné rozlišení odstínů šedé, což způsobuje horší vyhlazení písma - větší uhlopříčky trpí na off-center color/contrast shift Více detailů naleznete zde Další typy panelů, s kterými se můžete setkat: - MVA (Multi-domain Vertical Alignment) - PLS (Plane to line switching) - DLED () - QLED (Quantum dot LED ) - OLED (Organic light emitting diode) - AMVA Odezva Označuje dobu, za kterou je monitor zvládne zpracovat požadavek na změnu obrazu z počítače. Čím nižší odezva je, tím ostřejší obraz monitor poskytuje v rychlých scénách. Doba odezvy je důležitá zejména pro hráče počítačových her. U herních monitorů by neměla činit více než 4 ms. Odezva displeje udává dobu, během které se vymění obraz na displeji. Znamená to, že při nízké, respektive pomalé odezvě, se třeba ve hře odehraje něco, co vy ani nespatříte. Právě proto je odezva tak důležitý parametr pro hráče – zpoždění způsobené nízkou odezvou může dokonce způsobit, že na určité situace nemohou ani reagovat, protože je monitor nestihne zobrazit. Alza Barevná hloubka Barevná hloubka je termín používaný v počítačové grafice, který popisuje počet bitů použitých k popisu určité barvy pixelu v bitmapovém obrázku nebo rámečku videa. Toto pojetí je také známé jako počet bitů na pixel, zejména je-li uvedeno spolu s počtem použitých pixelů. Větší barevná hloubka zvětšuje škálu různých barev a přirozeně také paměťovou náročnost obrázku či videa. Wikipedie Pro představu: 12-bitový barvy jsou cca 200 Gbps datový tok, to 4× víc než nejnovější dostupný HDMI a více než 2x víc než nejnovější Display port 2.0 Kontrast Kontrast udává poměr zobrazené černé a bílé barvy při aktuálním nastavení vašeho monitoru. Správně nastavený kontrast oceníte zejména při sledování filmů či fotografií, umožňuje lepší prokreslení jednotlivých scén. Alza Doporučené odkazy Alza slovník pro monitory Jak vybrat monitor (zivecz)","tags":"Hardware","url":"https://nappex.github.io/myblog/choose-right-monitor","loc":"https://nappex.github.io/myblog/choose-right-monitor"},{"title":"Introduction to terminology in networks","text":"Resources My article is just rewritten form from articles below in my words, which I understand…. An Introduction to Networking Terminology, Interfaces, and Protocols published on digitalocean.com Local area network ( LAN ) Lokální síť u Vás doma. Ethernetová - vytvořená pomocí kabelů. Wide area network ( WAN ) Jedná se o Internet tam venku. Wireless local area network ( WLAN ) Bezdrátová lokální síť. Network Address Translation ( NAT ) Přeloží z privátní (lokální) IP adresu na public IP adresu MAC address (Media address control) Jedná se o unikátní adresu, která je pevné spojená se síťovým zařízením (síťová karta). Jedná se o adresu používanou ve vrstvě 2 - data link. Unikátní adresa je zařízení přiřazena výrobcem zařízení a nedá se změnit. Adresa se skládá z 6-ti octetů nebo bytů. Obsahuje tedy celkem 48 bitů. A zapisuje se v hexadecimální soustavě. Jak jsme si řekli, každé zařízení má svou unikátní adresu a v síti se tedy nemůže stát, že by dvě zařízení měli dvě stejné MAC adresy. Jedna adresa je ale speciální a to je broadcast address . Broadcast address má tvar -> FF : FF : FF : FF : FF : FF Broad cast adresa se používá když neznáme MAC adresu cílovéhé zařízení v takovém případě do požadavku k IP adrese připíšeme broadcast adresu, díky této adrese pošleme požadavek na všechny zařízení v síti a ozve se nám zařízení, které má požadovanou IP adresu. Communications types Unicast One to one communication. One speaking one listening Broadcast One to many. One speaking and everybody listening. It is little bit spammer beacuse it is sent you information also in case if you dont want to receive any. With broadcast is a lot of problems. Multicast One to many. Same as broadcast but multicast speaking just to who wants to listen. It means that I have register that I want to listen. If I dont let know to speaker that I want to listen then I dont receive any information. It works similar as when you subscribe some mail informations. OSI model Open Systems Interconnection model Tento model charakteruzije dílčí rozdělení síťových vrstev. Pro lepčí zapamatování slouží tyto mnemotechnické pomůcky: A ll P eople S leeping T hrough N etworking D on't P ass [ CCNA course od David Bombal - Udemy.com] A plikace potkala P rezentaci a R ealizovaly spolu T ransport S ítí spojením F yzickým. [wikipedie.org] Jednotlivé vsrtvy jsou: Physical layer (fyzická vrstva) Data link layer (linková vrstva) - ARP Network layer (síťová vrstva) - IP , DHCP , ARP , ICMP Transport layer (transportní vrstva) - TCP , UDP Session layer (relační vrstva) Presentation layer (prezentační vrstva) Application layer (aplikační vrstva) - HTTP , FTP , NTP , SSH , Telnet, SMTP , POP3 TCP / IP model Jedná se o model vycházející z OSI modelu, který je více zasazen do reality. Tvoří ho pouze 5 vrstev. To je způsobeno tím, že tento model slučuje 3 vrstvy do jedné. A to konkrétně, redukuje tři OSI vrstvy aplikační, prezentační a relační na -> pouze jednu APLIKAČNÍ. Výsledný model potom vypadá následovně dle CCNA course: Physical - we send bits 1 or 0 Data link - we send frames , MAC addresses Network - we send packets , IP addresses Transport - we send segments , TCP , UDP Application Jiné zdroje uvádějí zase tento model: Physical Layer - Copper, Fiber Optic Cables, Wireless transmitter Network Layer - Ethernet, ADSl, WiFi (předávání MAC address fyzických zařízení) Internet Layer - IP , ARP , DHCP , ICMP (předávání IP adres) Transport Layer- TCP , UDP (Způsob přenosu TCP -> spojitě, UDP –> nespojitě (videa)) Application Layer - HTTP , FTP , SMTP , POP3 , SSH , Telnet, NTP DHCP (Dynamic Host Configuration Protocol) Server Když se připojíme s naším počítačem do naší domácí sítě, tak náš počítač neví jakou má mít adresu a ani jakou adresu má náš router. Takže pošle tzv. Broadcast na tzv. Local Broadcast Address což je 255.255.255.255 a pokud máme zapnuté DHCP tak ten tento požadavek přijme a na základě něj nám přidělí Local IP Address z předdefinovaného DHCP Poolu což je rozsah lokálních address, které mohou být přiřazeny zařízením, které se připojují do naší lokální sítě. Díky toho nemusíme každému zařízení přiřazovat lokální IP adresu manuálně, ale je dynamicky a automaticky přiřazena díky DHCP serveru. Dynamicky přiřazovaná adresa ovšem může být někdy problém, protože pokaždé kdy se stejné zařízení připojuje do naší sítě tak může dostat jinou IP adresu než mělo naposledy. Nicméně dá se nastavit, aby určité zařízení mělo přidělovánu stále stejnou adresu. CAM Table Also known as CONTENT ADDRESSABLE MEMORY or FORWARDING TABLE It is a table where are saved MAC (Media address control) addresses. This table we can found in switches (layer 2 - data link). Many hosts can connect to switch. Every MAC address has certain number of interface by which can connect to switch. Example of table: MAC address Interface TTL 48:1B:34: ED :44:22 1 3 89:1B:34: ED :99:22 2 6 12:1C:34: ED :44:11 2 6 14:1F:14: EF :44:07 3 25 TTL - Time to live, it is a time how long the host will stay in table. The size of table is finite so when host exceed the time to live then the host is removed for table. Table is saved in RAM of device. Device constantly refresh information in the table. If we see two or more hosts ( MAC addresses) connected to one interface we can supposed that these hosts are connected via additional switch. PDU Protocol Data Unit Physical - PDU is bit 1 or 0 Data link - PDU is frame Network - PDU is packet Transport - PDU is segment Application Protokoly Network layer IP IPv4 format is: x.x.x.x where x is 8-bits so total size is 32-bits so 10.1.1.1 is equal in binary -> 00001010.00000001.00000001.00000001 Internet protokol - protokol síťové vrstvy Connectionless protocol - it does not create a session it just send Connection list protokol Every packets sends by IP is independet, every packet can be send by different path. Packets can be lost but TCP can resend losted packet. No data recovery features. IPv4 has hierarchical structure, we divide to two parts: - network address portion (Network ID ) - host address portion (Host ID ) Network Address Portion (Network ID ) and Host Address Portion (Host ID ) Network ID Identifies certain network Routers maintain routing tables that contains network Host ID Identifies certain endpoints on network as Laptop, TV , Phone, Printers, etc. Analogy is that Nework ID is as Street name and Host ID is certain number of house. Routing protocol in networks search Network ID (name of street) and than ARP (Address resolution protocol) search for certain endpoint (certain house with certain number) Address Classes First three Class (A, B, C) are UNICAST Traffic Class A First octet binary of IPv4 starts with 0 , so range is from 0.0.0.0 to 127.255.255.255 . But 127 is reserved for loopback (localhost), (example 127.0.0.1 ). And 0 is reserved for default network. These two number cannot be used at first position. SO real range which can be used is from 1.0.0.0 to 126.255.255.255 . First octet of IP address is Networks. The last three octer are Hosts. So when we have IP address 126.168.1.100 - 126 is Network portion and it determines Class A and 168.1.100 is Host portion. Example: 10.0.0.0 is Network ID (Network address portion) 10.1.2.3 is Host ID (Host address portion) So we can have same host portion in diferrent Network - 10.1.1.1 and 12.1.1.1 , these two IP addresses has same host portion and it is allowed because these devices are in different networks. One is in network with Network ID 10 and the other device is in Network with ID 12. You can imagine as houses with same number but on different streets. So imagine you have two houses - one house with street number 111 a the second house with street number 111. But first house is on Oxford street and the second one is on Long avenue street. So there are two different houses and there is no any conflict. Class B First octet binary of IPv4 starts with 10 one and zero not ten (1000 0000), so range is from 128.0.0.0 to 191.255.255.255 . First two octet of IP address is Networks. The last two octet are Hosts. So when we have IP address 130.168.1.100 - 130.168 is Networks, 130 -> Class B and Network portion, 168 -> Network portion and 1.100 is Host portion. Example: 172.16.0.0 is Network ID 172.16.1.2 is Host ID 172.17.0.0 is Network ID 172.17.1.2 is Host ID 173.16.0.0 is Network ID 173.16.3.3 is Host ID Class C First octet binary of IPv4 starts with 110 one, one, zero not one hundred ten (1100 0000). Zero moved to third place. So range is from 192.0.0.0 to 223.255.255.255 . But 127 is reserved for loopback, (example 127.0.0.1 ). And 0 is reserved for default network. These two number cannot be used at first position. SO real range which can be used is from 1.0.0.0 to 126.255.255.255 . First three octet of IP address are Networks. The last one octet are Hosts. So when we have IP address 130.168.1.100 - 130.168 is Networks, 130 -> Class B and Network portion, 168 -> Network portion and 1.100 is Host portion. Class D is MULTICAST Traffic First octet binary of IPv4 starts with 1110 one, one, one, zero (1110 0000). Zero moved to fourth place so range is from 224.0.0.0 to 239.255.255.255 . Link Local Multitask - 224.0.0.X OSPF - 239.1.1.1 OSPF (Open Shortest Path First) routing technology Class E is for reserved for future or experimental purposes (testing) First octet binary of IPv4 starts with 1111 one, one, one, one (1111 0000). Zero moved to fourth place so range is from 240.0.0.0 to 255.255.255.255 . Classes were replaced in 1993 by CIDR (Classless Inter-Domain Routing) Directed Broadcast Address and Denial of Service Attacks (DoS) First binary of host portion is fullfilled with ones as 1111 1111. binary 1111 1111 = decimal 255 Example: 172.16.255.255 , all hosts on network 172.16.0.0 receive the broadcast It is disable by default because of Denial of Service Attacks (DoS Attacks). Denial of service attacks is done by from device which is destination of attack. This device send a broadcast to another network and all device will reply to that broadcast. Local Broadcast Address all octet are filled with binary 1s. 1111 1111.1111 1111.1111 1111.1111 1111 = 255.255.255.255 Your computer sends broadcast to DHCP server on that broadcast the DHCP server create your local IP Address. Local Loopback Address IPv4 it is address which start with 127, so it is IP address class A. It is testing address. This address tests TCP / IP stack. It can be 127.0.0.1 or 127.127.127.127 . Generally 127.X.X.X is local loopback address, it is reserved for localhost. You can see it when you trying some web application. You've been trying it on localhost then you push to internet. It makes 16 million address that can not be used and range of IPv4 is limited. IPv6 local loopback address is ::1 Router's or switches loopback address Is something different than local loopback address. It is 10.1.1.1/32 Subnet mask or netmask It tells you which part of IPv4 address is for network and which part is for hosts. So imagine that your IP address is 192.168.1.3 every bits equal to one (1) is for network. every bits equal to zero (0) is for host. If we have subnet mast 255.0.0.0 in bits 11111111.00000000.00000000.00000000 -> than network is 192 and host portion is 168.1.3 If we have netmast 255.255.0.0 in bits 11111111.11111111.00000000.00000000 -> than network portion is 192.168 and host protion is 1.3 These is contiguous implemetation it means that we have ones in row and zeroes in row. Theres is also discontiguous it can be like that 11111111.00011111.00000000.00000000 but this implementation you should not meet in reality fortunately. CIDR - Class Inter-Domain Routing With these concept you can meet CIDR when you have IP address written like that 192.168.1.3/16 -> /16 this means subnet characterization. It means 16 bits of ones = 255.255.0.0. 1111 1111 is 8 bits of ones in binary is equal to 255 in decimal. Examples: 11111111.00000000.00000000.00000000 = /8 11111111.11111111.00000000.00000000 = /16 11111111.11111111.11111111.00000000 = /24 11111111.11111111.11111111.11111111 = /32 -> 4 * 8 bits = 32 bits Joke is that in reality you can have this type of subnet: 255.255.224.0 -> 11111111.11111111.11100000.00000000 How to recognize what is network and host by this subnet ? With bitwise AND For Network IP address: 192.168.33.12 (decimal) 11000000.10101000.00100001.00001100 (binary) Netmast: 255.255.224.0 (decimal) 11111111.11111111.11100000.00000000 (binary) ––––––––––––––––––––––––––––––––––––––––––––––––– 11000000.10101000.00100001.00001100 & 11111111.11111111.11100000.00000000 ––––––––––––––––––––––––––––––––––––––––––––––––– 11000000.10101000.00100000.00000000 (binary) 192.168.32.0 (decimal) –> Network prefix is 192.168.32.0/19 (16 + 3) For Host 11000000.10101000.00100001.00001100 (192.168.) & NOT (11111111.11111111.11100000.00000000) = 00000000.00000000.00011111.11111111 (13 bits) ––––––––––––––––––––––––––––––––––––––––––––––––– 00000000.00000000.00000001.00001100 (binary) 0.0.1.12 (decimal) –> Host prefix is 0.0.1.12 We have 8 + 5 bits = 13 bits of hosts -> 2&#94;13 = 8192 available addresses for hosts ARP Address Resolution Protocol Hledá MAC adresu cílového zařízení, od kterého známe pouze IP adresu. Jinými slovy se na síti ptá jakou MAC Adresu má zařízení, které má tuto IP adresu ? Zařízení s hlednou IP adresou odpoví já mám tuto IP adresu a má MAC adresa je tato. Počítače totiž většinou znají různé IP adresy, ale k nim neznají příslušné MAC adresy, abychom mohli zaslat plnohodnotný požadavek. Tak tento požadavek musí obsahovat, jak IP adresu tak MAC adresu, IP adresu známe, ale potřebujeme ji doplnit o MAC adresu to zjistíme právě pomocí ARP . Počítač neboli HOST se tedy učí MAC adresy na síti díky ARP . V praxi ARP funguje takto, aby byl požadavek úplná musí mít IP adresu a MAC adresu, když ale MAC adresu nemáme tak se místo konkrétní MAC adresy do požadavku dá tzv. broadcast MAC adresa ( FF : FF : FF : FF : FF : FF ). Tato adresa udává, že se má požadavek zaslat na všechny hosty v síti. Jakmile tento ARP požadavek připutuje i k HOST , který má požadovanou cílovou IP adresu, tak zašle nazpět svou konkrétní MAC adresu. Tímto způsobem pomocí ARP získá počítač A, který byl zdrojem požadavku MAC adresu počítače B, který je cílem komunikace. Informace o MAC adrese cíle se uloží do tzv ARP Cache. Při další komunikaci se tak už nezjišťuje jakou MAC adresu má cílový B počítač, protože tato informace už je v ARP počítače A uložena. ARP Cache se s informací o MAC adrese maže po vypršení TTL , která se vypočítává na základě velikosti paměti RAM nebo když zařízení A vypneme. Na svém pc se můžete podívat na ARP informace pomocí příkazů: Windows/MacOS arp -a Linux ip neighbour Transport layer TCP Transmission control protocol - primární přenosový protokol It sends SYN (synchornization info) to receiver. Than receiver sends back SYN AcK (synchronization Acknowledgment) to sender adn than sender send AcK (acknowledgement) to receiver back. Transmitter -> ( SYN ) -> receiver transmitter <- ( SYN AcK ) <- receiver transmitter -> ( AcK ) -> receiver It can resend lost (dropped), corrupted or misdirected packets from IP . UDP User Datagram Protocol Application layer HTTP / HTTPS (Hypet Text Transfer Protocol) FTP / FTPS (File Transfer Protocol)","tags":"Networks","url":"https://nappex.github.io/myblog/basics-terminology-networks","loc":"https://nappex.github.io/myblog/basics-terminology-networks"},{"title":"How get info about my IP address on macOS","text":"IP addresses Your home computer always contains two IP addresses. How local network works is described in picture below. Icons used in image was created by Mithun Raj on freeicons.io . Thank you :) Picture was created with Firealpaca What two addresses I mean ? There are: Internal (private) IP address - router interface when connects to local network External (public) IP address - router interface when connects to internet For example (see picture above) - your laptop has internal IP address 192.168.0.106 but external address is 89.35.8.107 Our home Nat router allows connections in direction from internal to external network (internet) and not vice-versa unless is used technique called port forwarding . There is no direct connection between the Internet and a computer (except port forwarding). So no one can not to connect to your internal IP address from internet. Only port forwarding allows device to get external IP address and reach this device from internet. Internal (private) IP address About Internal IP address is RFC 1918 we can set three types of private IPv4 address: Class A 10.0.0.0 - 10.255.255.255 (10/8 prefix) Class B 172.16.0.0 - 172.31.255.255 (172.16/12 prefix) Class C 192.168.0.0 - 192.168.255.255 (192.168/16 prefix) Another type of private address is 169.254.X.X - it is IPv4 Link Local Address, it is used when we connect two computer with cable. There can occure a problem when we want this pc add local IP address with DHCP . This can not allocate IP addres with DHCP because this PC will dynamicaly allocate IP address by itself. So this function can be used if we do not have a DHCP server to automatically allocate IP addres for our PC . This address is not routable so we can not route this address by internet or another subnet. This address is automatically allocate to host whene there is no DHCP server. Internal IP addresses use a special address range from a reserved non route-able address range. This range is same for every local network. Range is restricted for local usage. So the internal IP address ranges are blocked by Internet routers, you can not see them from internet. Internal IP addresses have these schemes in most cases: 192.168.0.x 192.168.x.0 other schemes of private IP can be: 10.x.x.x is a 24 bit address block 172.16.x.x to 172.31.x.x is a 20 bit address block. Your router has Internal IP probably as 192.168.0.1 or 192.168.1.0 Devices in your local network have these Internal IP addresses: PC 192.168.0.103 TV 192.168.0.104 Raspberry 192.168.0.105 laptop 192.168.0.106 You can locally connect many devices to your router. But all of these devices will have only one External IP address of your router. How to find out your internal IP addresses on macOS There are two commands to check your IP : ifconfig ipconfig When you prompt: $ ifconfig you should get output of all connections: lo0: flags = 8049 <UP,LOOPBACK,RUNNING,MULTICAST> mtu 16384 options = 1203 <RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP> inet 127 .0.0.1 netmask 0xff000000 inet6 ::1 prefixlen 128 inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1 nd6 options = 201 <PERFORMNUD,DAD> gif0: flags = 8010 <POINTOPOINT,MULTICAST> mtu 1280 stf0: flags = 0 <> mtu 1280 en0: flags = 8863 <UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1500 options = 400 <CHANNEL_IO> ether 78 :bf:9b:c3:6b:02 inet6 fd60::18:1a2f:dabe:c1dc%en0 prefixlen 64 secured scopeid 0x4 inet 192 .168.0.89 netmask 0xffffff00 broadcast 192 .168.0.255 nd6 options = 201 <PERFORMNUD,DAD> media: autoselect status: active en1: flags = 8963 <UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX,MULTICAST> mtu 1500 options = 460 <TSO4,TSO6,CHANNEL_IO> ether 82 :19:32:d2:ec:80 media: autoselect <full-duplex> status: inactive . . . Your output will be different in view of your OS . For Linux distributions you get these main variables: eth[0-x] : ethernet interface, to connect with cable lo : loopback or local, when you use localhost wlan[0-x] : wireless interface, to connect with wifi Output above is from macOS, there is some differents. See most of them below with explanation: lo0 : loopback (localhost) gif0 : Software Network Interface stf0 : 6to4 tunnel interface en0 : Ethernet 0 (ethernet), physical network connection en1 : Ethernet 1 (wireless), physical network connection fw0 : Firewire, IP over Firewire interface vmnet0 : Virtual Interface, interfaces are installed by VMware for network communication with virtual machines utun0 : Tunneling interface. Used for VPN connections to tunnel traffic or for software like Back To My Mack. creates VPN clients llw0 : Low-latency WLAN Interface. Used by the Skywalk system. ap1 : Access Point. This is used if you are using your MacBook as a wireless host where you are sharing its connection. awdl0 : Apple Wireless Direct Link. WIFI p2p connection for things like AirDrop, Airplay, etc. Also used for Bluetooth. llw0 : Low-latency WLAN Interface. Used by the Skywalk system bridge0 : Thunderbolt Bridge If you want to get shorter output, where you will find your IP addresses easier, prompt: $ ifconfig -a inet It means show me all active and inactive connections and their inet. Inet means IPv4 and inet6 means IPv6. When you prompt ifconfig withou -a it shows only active connetctions see documentations or there is nice explanation to other usage for example how configure addresses to an interface etc. inet : IPv4 ether : MAC address Other approach can be use command grep with ifconfig $ ifconfig | grep inet or $ ifconfig en0 inet If you want output only as your IPv4, then prompt: $ ipconfig getifaddr en0 ifconfig VS ipconfig ifconfig is used in UNIX OS and it means Interface Configuration. This command is the same as ipconfig, and is used to view all the current TCP / IP network configurations values of the computer ipconfig is used in Microsoft Windows but ReactOS or macOS support this command. It means Internet Protocol Configuration. This command is used to view all the current TCP / IP network configurations values of the computer When you dont want to use terminal for this quest you can read your internal IP address in you setting in macOS. system preferences –> network –> Wifi –> advanced –> TCP/IP –> address IPv4 How to find all devices on your local network For this purpose is the best choice to use tool called nmap Docs Tool nmap is not installed on macOS, so I recommend to instal via brew $ brew install nmap After installation you have to link the tool $ brew link nmap In my case I got a error Error: The ` brew link ` step did not complete successfully The formula built, but is not symlinked into /usr/local Could not symlink nmap /usr/local/share/.../.../man is not writable brew link nmap to fix this error use this command: $ sudo chown -R ` whoami ` :admin /usr/local/share whoami : is name your current user chown : tool for change file owner and group, see man chown -R : Change the user ID and/or the group ID for the file hierarchies rooted in the files instead of just the files themselves. When link is complete then you can scan your local network with nmap Command to scan your all active devices in your local network is: $ sudo nmap -sn 192 .168.0.0/24 It search all active connections with IP pattern 192.168.0.x. It is recommended to use as sudo because if you don't use as sudo you received very basic informations. -sn : Ping Scan - disable port scan, also called as quick scan in older version was -sP . This option tells Nmap not to do a port scan after host discovery. If you don't use this option, the you get result with open ports. /24 : is referring to the subnet mask. It is CIDR format. /24 means that the first 24 bits of the IP address are part of the Network number (192.168.0) the last part is part of the host address (1-254). Subnet-mask should be: 255.255.255.0 Network Address should be: 192.168.0.0 Broadcast Address should be: 192.168.0.255 Valid Hosts (Host range) should be: 192.168.0.1 - 192.168.0.254 Working for Host range: 2&#94;8 - 2 –> 256 - 2 = 254 /24 : is called as \"slash notation\". It's the number of bits that are specified. An IPv4 adress is 32 bits, divided up into 4 groups of 8 bits (n umbers from 0 to 255). 192.168.1.0/24 means any IP address in the range of 192.168.1.0 to 192.168.1.255. An IP address of 192.168.2.0/23 would be any IP address in the range 192.168.2.0 to 192.168.3.255 (notice the third number changes too) because it can have any value in the last 9 bits. Yahoo answers Also see the subnet calculation External (public) IP address External IP address is routable IP address. This address is assigned to you by your ISP . ISP has to assigned IP address to you from public addresses range which was assigned to your ISP by IANA (Internet Assigned Numbers Authority). IANA –> public addresses range –> ISP –> your external IP address External IP address is used when you communicate with Internet. You can notice that your External IP address change during the time. It is normal process because most of ISP gives you dynamic IP address . It means your ISP can change your External IP address how they need it. When you communicate with your devices from outside as a remote is good habit to have only one IP address without any change. For this purpose you need to get static IP address which is in most cases something extra and you have to pay for this service to your ISP . Make from private IP address the public is done via NAT (Network Address Translation) How to find out your external IP address From internet Check some service on the internet which will show you your external IP address. For example https://whatismyipaddress.com/ or just type to google my IP address and google will write to you… Terminal There is also web services which allow to use terminal. One of this service is https://ifconfig.me/ , so when you prompt: curl ifconfig.me or curl ifconfig.me/all or curl ipecho.net/plain ; echo","tags":"Networks","url":"https://nappex.github.io/myblog/ip-address-info-macos","loc":"https://nappex.github.io/myblog/ip-address-info-macos"},{"title":"Solve secret of all configuration format","text":"hackersandslackers.com/simplify-your-python-projects-configuration/","tags":"Python","url":"https://nappex.github.io/myblog/configuration-simple","loc":"https://nappex.github.io/myblog/configuration-simple"},{"title":"Install python and handle virtual environments on MacOS","text":"Intro Install python to MacOS There are two main ways how to install python to MacOS: Easy way for beginner - install by official package download from python.org Advanced way, but better - install with Homebrew $ brew Master way for developer - install different versions of python via manager pyenv In this article are mentioned ways 2. and 3. Homebrew What is Homebrew Homebrew is a free and open-source software package management system that simplifies the installation of software on Apple's macOS operating system and Linux. WIKIPEDIA It is same package manager as apt in Debian or dnf in Fedora distro. What is Homebrew Cask Homebrew Cask extends Homebrew and brings its elegance, simplicity, and speed to the installation and management of GUI macOS applications such as Atom and Google Chrome. Why Homebrew With using homebrew you have these benefits: better overview about your installed software comfortable installation and uninstallation process of software less probability that you destroy other things by installation process your MacOS can be in better condition, it simplier to hold your system clean with homebrew Install Homebrew to MacOS Detailed installation steps are described in Homevbrew-docs Requirements: A 64-bit Intel CPU macOS Mojave (10.14) (or higher) A Bourne-compatible shell for installation (bash or zsh) Command Line Tools ( CLT ) for Xcode If you own macOS you will meet criteria 1 - 3 for sure. But point 4. must not be meet. So to install Command Line Tools fo Xcode just write to terminal: $ xcode-select --install Next step is install homebrew package manager: $ /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh ) \" Finally check if installation was success $ brew doctor Your system is ready to brew. How to use homebrew Some basic command brew list Shows you what is installed $ brew list resp. for cask $ brew list --cask brew install $ brew install python3 resp. $ brew uninstall python3 How to keep your macOS clean Below are common steps to keep your brew clean: Steps are take from this article KEEP MACOS CLEAN brew update Update command will update the local base of available packages and versions, to be able to know what is updatable. $ brew update brew upgrade It actually installs new version of outdated packages $ brew upgrade brew cleanup -s By default, brew keeps all versions of the software, and you can link the one you want. This allow you to keep only linked versions (by default, the last) and save some disk space. This cleanup will apply to homebrew-cask also. Homebrew cask is a brew extension for GUI and binary packages, some software are installed with it for simplicity of updates. $ brew cleanup -s brew doctor and brew missing Will show you any problem with your brew installation, it will help a lot to maintain a healthy system all the time. $ brew doctor $ brew missing Install python via brew With homebrew you can install latest version of python3. $ brew install python3 If you want to install python2 $ brew install python@2 Installation Python with brew has disadvantage that we want to install multiply versions of python 3 it is very painfull process. Manage different version of python For managing different versions of python it is handy to know some commands which will help you to understand what is happened in background. Check what version of python is used: $ python -V Python 2 .7.16 or $ python3 --version Python 3 .9.0 If we want to check where is situated executable file of python which we promt python in terminal we will find out with: $ which python /usr/bin/python or $ which python3 /usr/local/bin/python3 With brew Theres is no way to install mulitply version of python 3 with homebrew. With pyenv Pyenv is simple Python version management. This tool was created because of painfull process when we need multiply versions of python on one PC . If we have several project where we needs specific version of python on each, then pyenv comes to scene. Install pyenv with homebrew pyenv can be installed with homebrew easily: $ brew install pyenv After installation pyenv with brew to macOS we have to make some settings for properly run pyenv. Next step is set pyenv init to end of config file of your shell. This will ensure atuocompletion and enable shims. for zsh echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\\n eval \"$(pyenv init -)\"\\nfi' >> ~/.zshrc for bash echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\\n eval \"$(pyenv init -)\"\\nfi' >> ~/.bash_profile Some systems (Ubuntu or Fedora) with bash use for config .bashrc instead of .bash_profile When pyenv init with echo restart your shell: $ exec \" $SHELL \" or $ source ~/.zshrc It is highly recommended to install with brew other dependecies for installing python with pyenv . So before installing any python to pyenv, install these dependecies: $ brew install openssl readline sqlite3 xz zlib After installation of these dependecies, brew write message for zlib: zlib is keg-only, which means it was not symlinked into /usr/local , because macOS already provides this software and installing another version in parallel can cause all kinds of trouble. For compilers to find zlib you may need to set: $ export LDFLAGS = \"-L/usr/local/opt/zlib/lib\" $ export CPPFLAGS = \"-I/usr/local/opt/zlib/include\" For pkg-config to find zlib you may need to set: $ export PKG_CONFIG_PATH = \"/usr/local/opt/zlib/lib/pkgconfig\" It is not necessary to set up. Set these variables just if problems occured Finally we can install certain version python with pyenv $ pyenv install 3 .8.6 If we want se what is installable prompt: $ pyenv install --list If we want to set certain version of python as global version prompt: $ pyenv global 3 .8.6 If we want to see installed versions: $ pyenv versions system * 3 .8.6 ( set by /Users/user_1/.pyenv/version ) system = python2 on macOS Now prompt: $ which python3 /Users/user_1/.pyenv/shims/python3 Sometimes rehash is needed, if your output is /usr/local/bin/python3 then prompt: $ pyenv rehash Rehashes shims: From time to time you'll need to rebuild your shim files. Doing this on init makes sure everything is up to date. You can always run pyenv rehash manually. If everything is set up correctly, then the python source should be located in shims Settings of PATH Configuration of PATH should be done automatically by pyenv init . Sometimes is necessary to set up path of shims manually to variable PATH of shell configuration. We have to add configuration of PATH above the code of pyenv init in shell configuration file (.zshrc, .bashrc, .bash_profile). Define environment variable PYENV_ROOT to point to the path where pyenv repo is cloned and add $PYENV_ROOT/bin to your $PATH for access to the pyenv command-line utility. For bash: $ echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' >> ~/.bash_profile $ echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' >> ~/.bash_profile For Ubuntu Desktop: $ echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' >> ~/.bashrc $ echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' >> ~/.bashrc For Zsh: $ echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' >> ~/.zshrc $ echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' >> ~/.zshrc Advanced configuration Check Advanced configuration of pyenv - GitHub Virtual environments Why use virtual environments Because we need for each project different verions of packages. There is problem - managing Python dependencies. Python has one big problem - you can't have multiple versions of the same package (e.g. pandas) installed on one version of python installed on your computer. So each time you run pip install , pip will check if that package is already installed on your computer. If it's not, it will install the latest version. Text above taken from Python developer's toolkit How use virtual environment Tools for comfortable use of virtual environments virtualwrapper See virtualwrapper documentation for more information Installation Virtualenvwrapper should be installed on your main python version and nothing else. The rest of all your programing magic and installation you have to make with with new virtual environment of python created by virtualenvwrapper or with built-in venv . If you don't want to install virtualwrapper on your OS python then there are options: pyenv pipx with these tools you are able to create new virtual envinronment as your main python and there is no need to handle with OS python. So your OS python will stay untouched. Installation command: $ python3 -m pip install virtualenvwrapper Usage Main configuration of virtualenvwrapper central dir where are saved all yours virtual environments. This DIR is called WORKON_HOME and default it should be set as $HOME/.virtualenvs Another central dir is where are save all yours development project - your sources of code of each project. This DIR is called PROJECT_HOME and default path will be in most cases $HOME/Devel location of your virtualenvwrapper.sh in most cases it will be /usr/local/bin/virtualenvwrapper.sh but if you want to be sure just prompt $ which virtualenvwrapper.sh this point is not in documentation but in my case I have to configure VIRTUALENVWRAPPER_PYTHON , because my default configuration was VIRTUALENVWRAPPER_PYTHON=/usr/bin/python that is path to my OS python2 in my case, but I've installed virtualenvwrapper to my OS python3 which is located in /usr/local/bin/python3 So I added this configuration to my .zshrc file: ~/ . zshrc export WORKON_HOME = $ HOME / . virtualenvs export PROJECT_HOME = $ HOME / Documents / Python / develop export VIRTUALENVWRAPPER_PYTHON =/ usr / local / bin / python3 source / usr / local / bin / virtualenvwrapper . sh Basic workflow of virtualenvwrapper: You have one location for your all virtual environments each environments can be linked with some project, so you can create project and connect with certain virtual environment at the start of project. Or you can connected already created project with new environment. Nice thing is that when you have linked your environment with your project and then you activate your environment with workon your_env , wrapper will move you to your project dir automatically. Basic commands WORKON to activate your virtual environemnt or show your environments $ workon your_env_1 your_env_2 The command below will activate your_env if linked to project it will move to your project dir. $ workon your_env_1 Deactivation env $ deactivate Create and remove virtual environment Probably you've already known way to make virtual environment with built-in venv as $ python -m venv name_your_venv . Make virtual env with vrtualenvwrapper is very similar but commands are different. At the end you have same virtual env as with built-in venv . mkvirtualenv Create a new environment, in the WORKON_HOME. $ mkvirtualenv your_env_name Options: -a option can be used to associate an existing project directory with the new environment. -i option can be used to install one or more packages (by repeating the option) after the environment is created. -r option can be used to specify a text file listing packages to be installed. The argument value is passed to pip -r to be installed. mkvirtualenv -a $HOME /myproject -r $HOME /myproject/requirements.txt -r $HOME /myproject/requirements-dev.txt your_env_name mktmpenv Create a new temporary virtualenv in the WORKON_HOME directory. $ mktmpenv This is a temporary environment. It will be deleted when deactivated rmvirtualenv ( mynewenv ) $ deactivate $ rmvirtualenv mynewenv $ workon $ pyenv-virtualenv pyenv-virtualwrapper pipenv","tags":"Python","url":"https://nappex.github.io/myblog/python-virtualenvs-installation","loc":"https://nappex.github.io/myblog/python-virtualenvs-installation"},{"title":"Comparing objects in python","text":"Comparison operators Python basic comparison operators: These operators compare the values of comparing objects. In other words we are comparing values saved inside the variable. Each int, float or string type is saved in memory as object in python. And we want to compare content of these objects with operators below. In generally, its are operators which we've already known from school. Operator Name Example == equal x == y != not equal x != y > bigger x > y < lower x < y >= bigger or equal to x >= y <= lower or equal to x <= y Python identical operators: These operators compared if two objects are same objects. For better understanding. Every object in python has its own id number . We can get id number of certain object in python by method id() . So when two objects are identical than they have same id number. Operator Description Example is Returns True if compared objects are same, if id number is same for both x is y is not Returns True if compared objects are not same x is not y See example below. Variable a and b have same values saved in but they have different id. >>> a = 3100 >>> b = 3100 >>> id ( a ) 4332864560 >>> id ( b ) 4332864880 Identical objects - The singletones The singleton is one of the simplest design pattern of object in Python. Examples of singleton are: None True False What does it means ? Whenever we create one of these object above in our code always will be one same object. It can't be two None objects with different id number. Although if we have two and more None in our code, always it is referenced to one object saved in memory. >>> id ( None ) 4407467184 All None objects in my certain code have id number equal to 4407467184 . Difference between == and is in examples >>> a = 3100 >>> b = 3100 >>> id_a = id ( a ) >>> id_b = id ( b ) >>> id_a 4332864560 >>> id_b 4332864880 >>> a is b False >>> a == b True Comparison a is b can be rewrite as id_a == id_b , so we just compare id number of each object, in other words if two id integers are same. In some cases it is much faster than compare values of objects, expecially when we compare list of values. Comparison a == b compares values saved in each variable. In this case we compare two integers saved in 3100 == 3100 . This explanation is same for != and is not . But with vice versa logic. Compare objects identical number in examples None examples: >>> def my_func () : ... return None ... >>> oliver = { \"age\" : 20 } >>> my_func () is None True >>> oliver.get ( \"height\" , None ) is None True >>> oliver.get ( \"age\" , None ) is None False >>> oliver.get ( \"age\" , None ) is not None True True examples: >>> 3 == 3 is True True Python will evaluate like that: 3 == 3 = True , than id(True) is id(True) = True Two lists: >>> a = [ 1 , 2 , 3 ] >>> b = a >>> a is b True >>> a == b True >>> b.append ( 4 ) >>> a [ 1 , 2 , 3 , 4 ] >>> b [ 1 , 2 , 3 , 4 ] >>> a is b True >>> a == b True >>> del a >>> a Traceback ( most recent call last ) : File \"<stdin>\" , line 1 , in <module> NameError: name 'a' is not defined >>> b [ 1 , 2 , 3 , 4 ] >>> a = [ 1 , 2 , 3 , 4 ] >>> a is b False >>> a == b True Notice at the end of code I've created new list a which has same values as list b . But when I've created new list, than the new list is a new object with new id number.","tags":"Python","url":"https://nappex.github.io/myblog/object-comparing","loc":"https://nappex.github.io/myblog/object-comparing"},{"title":"How I've published my pelican blog","text":"This is not a common article it is just instructions for myself how to publish my blog. How I invented structure of git and branches to publish my blog. Blog factory - main folder (pelican-blog/) You created first folder in your PC as pelican-blog. That blog became your first local repo. There is source raw data of everything. Every article in .md, your settings for pelican tool, your makefile, your pelican theme, your pelican plugin etc. This folder you can imagine as factory for creation of static sites. For this repo you have one branch - master , and one remote - your github with repo nappex.github.io Everytime when you done some changes in factory you can send your changes like that: $ git add -A $ git commit -m \"your message\" $ git push origin master Blog output (with static pages) - subfolder (output/) When you want to run static sites on GitHub pages, theres is recommendation to push your statis pages to branch with name gh-pages So you've created new folder with name output which is situates as subfolder of folder pelican-blog. And you make another repo from this folder with: Only one branch - gh-pages , and one remote - your github with repo nappex.github.io When you want to publish new output of static pages to GitHub, you have to make new outpu from factory. $ source venv/bin/activate for activation virtual environment where is installed pelican tool $ make html more info in pelican documentation After that we generate new content of output/ folder. By default is rewrite whole content of this folder with new files so .git file will be deleted. When we want to preserve file .git we have to append variable OUTPUT_RETENTION , with values as a list with names of files to be preserved, to configuration file pelicanconf.py situated in factory folder. The second variable describe path to output folder for html files. OUTPUT_RETENTION = [\".git\"] OUTPUT_PATH = 'output/' When all files are generated we can push our changes to see them all world. You have to change your main repo to subrepo of output folder. $ cd output/ $ git add -A $ git commit -m \"Your message\" $ git push origin gh-pages","tags":"Python","url":"https://nappex.github.io/myblog/blog-publish-me","loc":"https://nappex.github.io/myblog/blog-publish-me"},{"title":"Python project structure","text":"Intro There is no way how to make scheme of python project universal or general. Python let you done your project how do you want and there are no restrictions. But there are some common files or directories which you can notice in almost every project. These cases are described below. Files README README README .txt README .rst README .md Jak má vypadat README název projektu, stručný popis projektu (jedna až dvě věty), krátký návod k instalaci projektu, krátký návod ke spuštění projektu, krátký návod k používání projektu, případně odkaz na rozsáhlejší dokumentaci, pokud má projekt testy, informace o tom, jak je spustit, informace o tom, jak se zapojit do vývoje projektu, informace o autorech projektu, informace o licenci (více se licencích dozvíš později). Více info na: naucse.python.cz/2020/brno-jaro-pondeli/git/collaboration/ LICENSE setup setup.py setup.cfg script modules tox.ini requirements.txt test_requirements.txt dev_requirements.txt requirements-dev.txt .gitignore .travis.yml .python-version This file we can see in project which using tool pyenv . This library handle python versions in PC , virtual environments etc. With that file pyenv recognize which python version or which virtual environment is set for this project. Makefile Directories docs tests .github","tags":"Python","url":"https://nappex.github.io/myblog/python-scheme","loc":"https://nappex.github.io/myblog/python-scheme"},{"title":"Cvičení k programování","text":"1. Zadání pro web scraping Napište scraper pro stahování dat nejnovějších článků z online serverů. Scraper bude vycházet ze stránky seznamu nejnovějších článků a postupně se \"proklikávat\" do detailu jednotlivých článků, případně seznamu komentářů. Ze stažených článků se pokuste vyextrahovat maximum dostupných relevantních informací (nadpis, datum zveřejnění, autor, vlastní text, komentáře, počet zhlédnutí, …) a uložíte do NoSQL databáze. Nad uloženými daty napište jednoduché API (např. flask), které dokáže vracet (vyberte si alespoň 2): N nejnovějších článků N nejkomentovanějších článků N nejpoužívanějších slov N nejdelších slov Technologie: Povinné Python 3.x knihovna Scrapy NoSQL databáze MongoDB knihovna Flask Doporučené Docker Pytest cokoliv :) Level Python Guru Jupyter Pandas","tags":"Exercises","url":"https://nappex.github.io/myblog/exercises","loc":"https://nappex.github.io/myblog/exercises"},{"title":"Introduction to web scraping with python","text":"1. Jak začít …. Nejlepší je si vymyslet projekt, pro který by se vám web scraping hodil. Mě se třeba líbí testovat si různé online magazíny jako neviditelnýpes.cz, irozhlas.cz nebo aeronet. Ale můžete si udělat třeba hlídač cen. Vybrat si webovou stránku, která vás zajímá. Stránka by neměla mít pro začátek moc javascriptu, protože scrapovat javascript je složitější než čisty kód html. Čím více je stránka html, tím lepší pro první web scraping. Výběr technologie pro začátek doporučuji třeba knihovny - requests + beautiful soup . Nejčastěji doporučovaná kombinace pro začátečníky. Zkusit si udělat nějakou analýzu nad staženými daty pomocí python knihovny pandas . Nebo script, který pomocí crontab bude stahovat a ukládat data měnící se v čase. 2. Python nástroje pro web scraping Pro web scrap jsou nejznámější technologie Selenium, Beutiful Soup a Scrapy. Selenium - je framework pro testování webových aplikací. Funguje na principu otevři prohlížeč zadej do něj URL a zkoušej různě vyplňovat dotazník či formulář. Selenium vidí pouze to co vidíte vy v prohlížeči. Hodí se na práci s Javascriptem. Beautiful Soup - jedná se o knihovnu, kterou je do pythonu nutné doinstalovat. V současné chvíli se používá beautifulsoup4. Tato knihovna je schopna z kódu HTML vytáhnout potřebné informace. Bohužel nedokáže sama poslat požadavek na server. Musíme tedy pro posílání požadavků využít jiných knhoven například requests. Po získání HTML dané stránky je nutno ještě parsovat kód pomocí parserů v beautifulsoup4. Následně vlastně procházíme čistý text (string) HTML kódu a podle HTML tagů a jinýc h v něm hledáme potřebné informace. Tato knihovna je vhodná po snadné úlohy, které se zaměřují na scrap jednoho indexu webové stránky. Ne že by nebylo možné procházet více stránek, ale pro procházení více stránek je třeba si logiku napsat sám manuálně. Tato knihovna se pro začátečníky doporučuje. Jedná se snadnou knihovnu, která má docela pěkně napsanou dokumentaci. Pokud se chcete zabývát web scrapingu doporučuji začít touto knihovnou a různě si zkoušet. Pomocí bs4 jste schopni rychle dosáhnout poměrně pěkných výsledků, které vás budou motivovat do další práce. Komunita je docela velká a projektu se aktivně věnuje. Knihovna je docela pomalá, ale na nazačátek nebo malý scrap to vůbec nevadí. Scrapy - opensource framework. Jedná se o kanón na web scraping pomocí, kterého jste schopni dělat scrap a crawl na vysoké úrovni. Framework je také přenositelný a je možné použití na Linux, iOS nebo Windows. Je velmi rychlý až 20x rychlejší než jiné nástroje. Framework se používá už na profesionální a plnohodnotný scrap. Je schopen posílat několik requestů najednou a probublávat stránkou skrz naskrz. Bohužel pro začátečníky není úplně nejvhodnější, protože jeho dokumentace je složitější a také vytvářené objekty pro scrap jsou poměrně už vyšší python. Sám jsem ze scrapy ze začátku dost zmatený jako začátečník. Daleko lépe se mi orientuje v Beautiful soup. Na velký komplexní projekt je jednoznačná volba Scrapy. Jednoduché shrnutí: Na Javascript - Selenium Velký komplexní projekt, který má být snadno přenositelný a rychlý - Scrapy Jste začátečník v pythonu nebo ve scrapu - Beautiful Soup 3. Scrap vs Crawl Mám docela chaos o tom co znamená scrap a crawl. Na internetu se používají oba pojmy a většinou nejsou vysvětleny. Někdy je míchají dohromady jindy používají jen jeden nich. Vyznat se v nich může být matoucí, protože oba pojmy spolu velmi úzce souvisí. Tak jak to je ? scrap: Anglicky to scrape znamená škrábat nebo seškrábnout. Scrap je definován jako škrábání informací strojovým způsobem z webových stránek. Jelikož data a informace můžete pouze prohlížet web scrap je způsob, jak získat data ze stránek fyzicky a uložit si je do databáze a dále nad nimi provést nějakou analýzu pomocí knihovny pandas. Tedy stahujeme konkrétní data, které potřebujeme. Scrap se skládá ze těchto kroků: request-response parse and extract - parsování znamená převzít kód hmtl (markup language s jednoduchou strukturou) a přenést ho do obyčejného textu, který je počítač schopen zpracovat. Data extrahujeme pomocí regulárních výrazů (regex) hledání speciálních tagů apod. stažení dat - ve formátě JSON , CSV nebo do databáze. crawl: Anglicky to crawl znamená plazit se. Používá se to ve spojení plazení pavouka (spider crawling). Jedná se o procházení a indexování stránek. Crawling dělají služby jako Google, Yahoo apod. Děláte víceméně to co vyhledávače. Mohli bychom takový program nazvat třeba také searchbot, searchengine. Hledáte různé stránky na webu a indexujete je. Následně si je ukládáte všechny dostupné cesty a zákoutí do databáze. Z toho pak vidíte všechny možné cesty odkud můžete scrapovat data na daném webu. Select a starting seed URL or URLs Add it to the frontier Now pick the URL from the frontier Fetch the web-page corresponding to that URL Parse that web-page to find new URL links Add all the newly found URLs into the frontier Go to step 3 and reiterate till the frontier is empty Scrap vs Crawl shrnutí: Jednoduše to zatím chápu tak, že crawlujete stránky, z kterých postupně jak je crawlujete scrapujete data, které potřebuje. Tedy procházím stránku po stránce a vždy si na každé stránce stáhnu informace, které potřebuji. 4. Je to vůbec legální ? Před začátkem práce by si měl každý uvědomit, zda ho jeho činnost nemůže dostat do kriminálu. Uvedu zde několik bodů, které jsem našel, aby scrapování bylo zcela OK . Když se zamyslíme, tak scrap není nic jiného než procházení stránek a stahování informací strojovou metodou. Když manuálně procházíte webové stránky děláte vlastně přesně to samé akorát mnohem mnohem pomaleji. Když byste stránky procházeli přes webový prohlížeč a nalezené informace byste si psali na papír tak je postup naprosto stejný. Ovšem rozdíl nastává v oné zmíněné rychlosti a také v tom, jak následně s těmito daty naložíte. Ne všechna data se mohou automaticky zveřejňovat dále, jelikož spadají například pod autorské práva. Některé stránky mají přímo ve svých pdomínkách napsáno, že zakazují použití crawl/scrap/harveting strojovou metodou. Tedy i když děláte to samé jako prohlížeč a manuálně tak pro mnoho společností to není to samé. \"Terms of Service (ToS) often prohibit automatic data collection, for any purpose\"[1]. Takže když si dají do podmínek, že je zakázáno sbírat data strojově tak Váš postup bude nelegální i když vlastně procházíte stránku jako byste ji procházeli manuálně. Uvědomte si, že i zde platí zákon o soukromém vlastnictví a všchny stránky někomu patří a ten si může nstavit, jak bude s jeho soukromým vlastnictvím nakládáno. Pokud nebudete dodržovat podmínky vlastníka těchto informací říkaté si o problém. Základní pravidla legálního scrapingu: API - Pokud daná služba poskytuje pro Vaše účely API (data, které potřebujete získat poskytují například ve formátu JSON skrze API ) měli byste využít toto API . Například kurzovní lístek z ČNB je nabízen formou API v .txt souboru. V takovém případě tedy nebudu scrapovat celou stránku (rozumněj HTML kód) ČNB abych kurzy získal, ale využiji jejich API . Frekvence požadvků - Je nutné, aby jste ve svém skriptu měli nastavenou frekvenci stahování a procházení tak, aby jste neshazovali server - nadměrně nezatěžovali server požadavky. Ono nadměrným posíláním požadavků nemusíte rovnou shodit server, ale můžete jej zpomalovat pro další uživatelé. Shozením serveru nebo zpomalováním můžete poškodit značku nebo stránky a tuto škodu po Vás může potom někdo chtít nahradit. Myslím, že třeba scrapy tohle řeší už za vás. Neúměrné stahování dat a dokonce shození serveru je tedy také trestné. Doporučená frekvence je 1 požadavek (request) za 10-15s. Pokud budete používat toto pravidlo neměli byste způsobit žádné peklo - mělo by to vypadat jako klasické manuální procházení stránek na které jso uweby stavěny. Autorské práva či ostatní práva vztahující se na data - Zkontrolujte jaká autorská práva či jiná práva se vztahují na data, které si chcete stahovat. Zda se nejedná o soukromé data. Stahování dat s autorskými právy a jejich další komerční využití je neetické a nelegální. Veřejné data - Zpracování veřejně dostupných dat by mělo být zcela OK . Ovšem mějte na paměti, že i toto může zcela změnit Terms of Service a i veřejně dostupné data nemusí být k použití. robots.txt - Provádějte scraping v souladu s pravidly, které naleznete v souboru robots.txt. Jedná se o soubor, který dá k dispozici webová stránka a popisuje v něm, jak má být Váš robot nastaven, aby jste mohli danou stránku crawlovat a scrapovat. V souboru může být taky uvedeno, že na stránku nesmíte žádného robota použít. Pokud nebudete dodržovat podmínky uvedené v tomto souboru vystavujete se riziku soudního sporu. Níže naleznete jaké informace můžete v takovém robotovi nalézt. ToS Terms of Service - podobně jako robot.txt fungují také všeobecné podmínky, smluvní podmínky nebo podmínky (pravidla) pro používání webové stránky, které je také dobré si přečíst než začnete pracovat na web scrapingu. A dodržovat je. Většinou je naleznete jako odkaz někde úplně dole na hlavní stránce. Jako příklad může posloužit portátl irozhlas.cz, kde úplně dole naleznete link Podmínky užití - Podmínky užití obsahu Českého rozhlasu Nejpodstatnější je co se s staženými daty budete dělat a jaký způsobem budete data získávat. Pokud budete data používat pouze pro své účely a nebudete je šířit na internetu nebo používát pro komerční účely, tak byste měli být OK . V opačném případě je dobré zkontrolovat zda k tomu máte oprávnění. Ono i když budete dodržovat robots.txt, ale nebudete dodržovat ToS, tak jste zase v průseru, ovšem stránka, která v ToS zakazuje strojové procházení. Ovšem procházení může být zakázáno i v robots.txt je nutné číst obojí. A hlavně nezapomínejte na důležitou věc logika, pravda nebo férovost nemá s právem nic společného. Právo závisí také dost na interpretaci lidí a kvalitě Vašeho právníka. Rozhodně nedoporučuji se hájit sám v prípadě právní pře. Jak postupovat Use an API if one is provided, instead of scraping data. Respect the Terms of Service (ToS). Respect the rules of robots.txt. Use a reasonable crawl rate, i.e. don't bombard the site with requests. Respect the crawl-delay setting provided in robots.txt; if there's none, use a conservative crawl rate (e.g. 1 request per 10-15 seconds). Identify your web scraper or crawler with a legitimate user agent string. Create a page that explains what you're doing and why, and link back to the page in your user agent string (e.g. ‘ MY - BOT (https://yoursite.com/mybot.html)') If ToS or robots.txt prevent you from crawling or scraping, ask a written permission to the owner of the site, prior to doing anything else. Don't republish your crawled or scraped data or any derivative dataset without verifying the license of the data, or without obtaining a written permission from the copyright holder. If you doubt on the legality of what you're doing, don't do it. Or seek the advice of a lawyer. Don't base your whole business on data scraping. The website(s) that you scrape may eventually block you, just like what happened in Craigslist Inc. v. 3Taps Inc.. Finally, you should be suspicious of any advice that you find on the internet (including mine), so please consult a lawyer. Body jsou převzaty z \"Příklady soudů a mýtů kolem legální nelegální\" 5. Soubor robots.txt S jakými pravidly se můžete setkat v tomto souboru A. Povolen plný přístup Můžete přistupovat ke všem stránkám na webu pomocí robota, bota, stroje. Plný přístup poznáte tak, že bude v souboru uvedeno: User-agent: * Disallow: B. Blokování všech přístupů Na takové stránce není dovoleno strojově proházet data. V souboru bude uvedeno: User-agent: * Disallow: / C. Částečný přístup Na takovém webu můžete strojově procházet pouze stránky na webu, které nejsou v souboru definovány jako zakázané např.: robots.txt User-agent: * Disallow: /some_folder/ robots.txt User-agent: * Disallow: /register.hmtl/ D. Limit frekvence prolézání webu (Crawl rate limit) Doba mezi jednotlivými požadavky. Nemůžeme poslat několik požadavků najednou, ale vždy jen jeden a potom musí být časová pauza. V uvedeném příkladě je nutné nastavit frekvenci požadavku jednou za 11 sekund, vždy lze nastavit pouze doba mezi jednotlivými requesty: robots.txt .... .... Crawl - delay : 11 E. Určený čas pro scrap a crawl (Visit time) Časové okno, kdy je dovoleno provádět strojové procházení stránek. Obvykle bývá nastaveno mimo špičky provozu. Uvedený příklad říká, že je možné dělat web scraping v časovém oknu 06:00 - 08:30 UTC . robots.txt .... .... Visit - time : 0600 - 0830 F. Frekvence požadavků (Request rate) Je počet requestů za časovou jednotku například 15/1m znamená, že můžeme poslat 15 requestů najednou za a pak čekáme do konce uplynutí jedné minuty, tedy neděláme nic, pak pošleme dalších 15 requestů. Některé stránky dovolují načítat několik stránek najednou. A požadují nastavení frekvenci requestů. Uvedený příklad požaduje nastavení maximálně 2 requesty za 10 sekund. robots.txt .... .... Request - rate : 2 / 10 Použité zdroje - další studium Beautiful soup: Datová analýza webscraping naucse.python.cz Corey Schafer - youtube channel web scrapin Python nástroje pro web scraping - srovnání: Medium.com scrapy vs selenium vs beatiful soup Je to vůbec legální ?: How to read and respect robots file What is web scraping Is web scraping legal ? Příklady soudů a mýtů kolem legální nelegální","tags":"Python","url":"https://nappex.github.io/myblog/python-scraping-introduction","loc":"https://nappex.github.io/myblog/python-scraping-introduction"},{"title":"Relace (vztah) mezi databázemi (tabulkami)","text":"Databáze - obecně Každá databáze se skládá z entit. Třeba databáze uživatelů je databáze entit, kde každý uživatel je jedna entita. Tato entita je definována svými atributy. Tyto atributy mohou být rodné číslo, jméno, přezdívka, email apod. A každý atribut má svou hodnotu. Hodnota emailu může být třeba pepanovak@seznam.cz. 1. Žádný vztah Mezi tabulkami nebo databázemi není žádný vztah. 2. Vztah 1:1 one-to-one Tento vztah není příliš častý, jelikož z dvou tabulek, které mají mezi sebou tento vztah můžeme většinou vytvořit jednu. [1] 3. Vztah 1:N one-to-many Můžeme si představit jako jednoho zákazníka z nějaké databáze, který vytvoří novou databázi ve formě několika objednávek. Nebo máme jednoho uživatele na blogu, který vytvoří několik postů. Ale každý post má pouze jednoho autora. V tomto případě se vztah nejčastěji řeší přidáním jednoznačného identifikátoru (foreign key) zákazníka nebo uživatele (např. user_id, customer_id) do každého řádku databáze objednávek či postů blogu. Každá objednávka nebo post tak bude identifikovatelná, kým byla vytvořena. [1] 4. Vztah M:N many-to-many Tato relace je mezi tabulkami Výrobky a Objednávky. Jedna objednávka může obsahovat více výrobků. Na druhou stranu se jeden výrobek může objevit v mnoha objednávkách. Pro řešení tohoto vztahu se musí vytvořit třetí tabulka, která je charakterizovaná vztahem 1:N a 1:M. Použité zdroje - další studium [1] - https://support.microsoft.com/cs-cz/office/p%c5%99%c3%adru%c4%8dka-k-relac%c3%adm-mezi-tabulkami-30446197-4fbe-457b-b992-2f6fb812b58f?ui=cs-cz&rs=cs-cz&ad=cz [2] - https://docs.microsoft.com/cs-cz/office/troubleshoot/access/define-table-relationships [3] - https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-viii-followers","tags":"Databases","url":"https://nappex.github.io/myblog/databases-relations","loc":"https://nappex.github.io/myblog/databases-relations"},{"title":"Python knihovny pro práci se soubory","text":"1. Knihovna pathlib Jedná se o knihovnu, která je od pythonu 3.4 built-in a není tedy potřeba ji doinstalovávat. Základní použití knihovny vypadá následovně import pathlib pathlib . Path ( \"folder1/folder2/run.exe\" ) Output : PosixPath ( 'folder1/folder2/run.exe' ) Výše je základní příkaz třídy Path pomocí které se vytváří cesta - objekt cesty. Výstupem tohoto příkazu je PosixPath(\"cesta\") Základem používání této knihovyn je vytvoření objektu ze stringu pomocí příkazu pathlib.Path('vase/cesta/nekam') . Po vytvoření objektu PosixPath si můžete s touto cestou hrát dle své libosti pomocí široké škály method a atributů, které tento objekt na danou cestu poskytuje. Třída Path se dá použít i bez toho, aniž bychom museli zadat cestu. Třída disponuje metodami jako například cwd() - vypíše current working directory nebo home() - který vypíše absolutní cestu k vaší domovské složce. Z dokumentace můžete být trochu zmatení z těchto dvou příkazů pathlib.Path() vs pathlib.PurePath() na první pohled totiž není mezi nimi většího rozdílu. Nicméně po detailním prostudování dokumentace Pathlib dokumentace zjistíme tyto rozdíly: Každý dělá jiný typ objektu - Path() vytvoří objekt PosixPath kdežto PurePath vytvoří PurePosixPath . Path() disponuje navíc dalšími metodami, kterými si může šáhnout do souborů na počítači. PurePosixPath naopak nemá přístup do systému. Spojování cest Vytvářet či spojovat cesty můžeme několika způsoby: from pathlib import Path p = Path('/home/george/Documents/hello.txt) p = Path('/', 'home', 'george', 'Documents', 'hello.txt') p = Path('/home') / 'george' / Path('Documents', 'hello.txt') p = Path('/home').joinpath('george', 'Documents', 'hello.txt') pathlib.Path.cwd() Zjistí v našem systému current working directory. Tedy složku v které se právě nacházíme. pathlib . Path . cwd () Output : PosixPath ( '/Users/your_name/Documents/Python' ) pathlib.Path.home() Vypíše domovskou adresu našeho účtu v operačním systému. Na linuxu by mohla výstupní cesta vypadat jako /home/user_1/ pathlib . Path . home () Output : PosixPath ( '/Users/your_name' ) pathlib.Path(\"relativni_cesta\").resolve() Tato metoda nám vytvoří z relativní cesty cestu absolutní. Ovšem pozor, pokud zadáte cestu, která obsahuje lomítko na začátku cesty, tak tento zápis cesty znamená, že zadávate už absolutní cestu. Cesta s lomítkem pathlib . Path ( '/files_introduction/index.ipynb' ). resolve () Output : PosixPath ( '/files_introduction/index.ipynb' ) Cesta bez lomítka pathlib . Path ( \"files_introduction/index.ipynb\" ). resolve () Output : PosixPath ( '/Users/your_name/Documents/files_introduction/index.ipynb' ) 1. Otevírání souborů Klasické otevírání souborů vypadá nějak takto: with open(path, mode=\"r\", encoding=\"UTF-8\") as file_: S knihovnou pathlib lze soubory otevírat velmi podobným způsobem: with pathlib.Path(\"cesta\").open(mode=\"r\", encoding=\"UTF-8\") as file_: nebo také to samé rozepsáno: path = pathlib.Path(\"cesta\") with path.open(mode=\"r\", encoding=\"UTF-8\") as file_: Tímto způsobem je spuštěno open() stejně jako v prvním přikladě, ovšem zápis může být pro někoho příjemnější nebo intuitivnější. V zásadě se ale jedná o totéž. Pomocí třídy Path můžete pro zápis nebo čtení souborů, otevírání souborů rovnou přeskočit pomocí method - read_text() , read_bytes() , write_text() , write_bytes() pathlib.Path(\"cesta\").read_text() 2. Knihovna os.path Knihovna os nám pomáhá při práci s počítačem všeobecně. Konkrétně os.path je určena pro práci s cestami. Knihovna je velmi podobná knihovně pathlib, s tím rozdílem, že pathlib je o něco intuitivnější a jeho metody a atribute se mohou svými nazvy lišit. Nicméně pro základní používání najdete obou v knihovnách metody se stejnou funkcí. Tabulku, kde uvidíte, které metody jsou pro obě stejné naleznete v dokumentaci pathlib - corresponding to os module úplně na konci. 3. fnmatch Pomocí tohoto modulu vytváříme patterny, dle kterých hledáme soubory či adresáře. Nejedná se o regexy to je úplně něco jiného fnmatch 4. glob Metoda glob se používá pro vyhledávání souborů, se specifickým názvem (např. vyhledej v adresáři všechny soubory s příponou .txt), tento název konfigurujeme pomocí fnmatch viz. dokumentaci pathlib - glob nebo v naucse.cz Použité zdroje - další studium Portál naučse: naucse.python.cz/2019/brno-jaro-2019-pondeli/intro/pathlib/ RealPython: realpython.com/python-pathlib/","tags":"Python","url":"https://nappex.github.io/myblog/files-introduction","loc":"https://nappex.github.io/myblog/files-introduction"},{"title":"Konverze Jupyter notebooku do dalších formátů","text":"1. Vytvoření prezentace (slideshow) ze souboru .ipynb Pokud si uděláte analýzu dat a potřebujete z ní potom udělat nějakou pěknou prezentaci třeba pro šéfa, tak jupyter notebook má své řešení. Což je super jelikož nemusíte řešit další appku či software. Celé je to celkem super easy. Jupyter notebook vytváří prezentace ve formátu html . Mě se toto řešení osobně velice líbí, protože takovou prezentaci spustíte dnes na každém počítači a není rozházená. Navíc se velmi intuitivně ovládá pomocí šipek. Abyste mohli vytvořit prezentaci tak musíte postupovat následovně. Musíte mít nainstalován v pythonu jupyter notebook. Poté stačí do příkazové řadky napsat: $ python3 -m jupyter nbconvert <path_to/your_file.ipynb> --to slides pořádí nemá vliv $ python3 -m jupyter nbconvert –to slides Výstupem tohoto řádku je soubor your_file.slides.html , který se uloží do složky, v které je uložen zdrojový soubor určený ke konverzi tedy např. /folder1/folder2/your_file.ipynb . Tento soubor je vaše nová hotová prezentace. A co jednotlivé části kódu znamenají ? python3 - budeme pracovat s pythonem3 -m - načti pythonní modul. Nebo budeme používat modul z python3 jupyter - modul z pythonu3, který budeme používat má název jupyter nbconvert - z modulu jupyter použij nástroj nbconvert, který se stará o konvertování do jiných formátů --to - je jeden z aliases nástroje nbconvert, který říká do jakého formátu chceme náš soubor konvertovat slides - jeden z možných výstupních formátů. slides nám vytvoří formát .slides.html, ale můžeme místo slides napsat třeba jen html a dostaneme čisté hmtl. <path_to/your_file.ipynb> - cesta k souboru, který byl vytvořen pomocí jupyter notebooku a chceme z něj udělat prezentaci či jiný formát 2. Vytvoření prezentace bez python nebo jiného programovacího kódu Je to stejné jako v předchozím případě, jediné v čem se to liší je použití navíc tzv flags. Kód do příkazové řádky: $ python3 -m jupyter nbconvert your_analyze.ipynb --to slides --no-input Oproti předchozímu příkladu přibyl jeden flag navíc a to --no-input . Který zajistí, že se v prezentaci nebude objevovat kód neboli buňky které nejsou typu markdown. Pro tento účel lze ještě použít flag --no-prompt , ale ten nemám zcela ošahaný. Jaké existují flags and aliases pro nbconvert naleznete v dokumentaci, kterou uvádím v užitečných odkazech. 3. Vytvoření html ze souboru .ipynb Jak bylo zmíněno v kapitole 1 změna výstupního formátu je pouze o tom, jaký formát nastavíme pro alias --to . Kód by vypadal takto: $ python3 -m jupyter nbconvert --to html <path_to/your_file.ipynb> Použité zdroje - další studium Flags and aliases - nbconvert Medium article about presentation","tags":"Jupyter","url":"https://nappex.github.io/myblog/jupyter-convertion","loc":"https://nappex.github.io/myblog/jupyter-convertion"},{"title":"Git - fix your history","text":"1. Změna posledního commitu S příkazem commit můžeme použít tzv. flags , které upravují chování tohoto příkazu. Jedním z takových flags je --amend . Pomocí tohoto flags měníme poslední commit. Pomocí přikzu $ git commit --amend můžeme: 1. kombinovat změny, které máme v tuto chvíli ve staged fázi s posledním commitem 2. změnit poslední commit message , v které jsme udělali chybu nebo překlep. Ovšem tato změna změní uložení commitu a v historii ji budeme vidět s hvězdičkou (*). Tedy vytvoří se nový commit se stejnými informacemi, ale jinou zprávou a navíc bude obsahovat hvězdičku. 1. Přidat soubory ve staged fázi do posledního commitu Představme si následující sled událostí: Editujeme soubory hello.py a main.py . Po ukončení změn přidáme do gitu pouze main.py a provedeme commit. V příkazové řádce by úkony vapadly nějak takto: $ git add main.py $ git commit V tuto chvíli si autor uvědomí, že zapomněl přidat do gitu také soubor hello.py , který chtěl mít ve společném commitu také se souborem main.py , který už je ale v tuto chvíli commitnutý. Tento problém se při vývoji objevuje poměrně čast a git si s touto situací umí hravě poradit. Postup opravy může vypadat takto: $ git add hello.py $ git commit --amend --no-edit Použitý flag --no-edit nám zajistí, že se zapomenutý soubor přidá do posledního commitu, ale commit message se nezmění. Tedy flag --no-edit = chceme přidat nové změny do posledního commitu bez úpravy commit message . 2. Změna zprávy v posledním commitu Pro změnu poslední commit message použijeme tento příkaz: $ git commit --amend Tímto příkazem se nám objeví námi defaultně nastavený editor textu pro git a v něm poslední zpráva tu můžeme libovolně upravit a následně změny potvrdit, jak jsme zvyklý u běžných commitů . Jednořádková změna commit message se provádí pomocí príkazu: $ git commit --amend -m \"your new or updated commit message\" Když přídáme do příkazu options -m můžeme změnit ři přepsat commit message přímo v příkazové řádce aniž bychom museli otevírat textový editora celý proces se takto výrazně zrychlí. Upozornění : Příkaz amend nepoužívejte pokud jste změny už poslali do public prostoru třeba na GitHub. Jelikož --amend udělá nový commit, tak bude problém jej pushnout do stejné větve na remote. Jak jsme si řekli --amend udělá nový commit na větvi a ten starý z ní zmizí, při pushnutí této změny dojde ke konfliktu. 2. Změna jednoho, libovolně starého commitu Změna se provádí pomocí příkazu git rebase . Tento příkaz je poněkud složitější a podíváme se tedy na něj v kapitole Git rebase trochu blíže. Pro změnu konkrétního starého commitu můžeme použít tento příkaz: $ git rebase <id_old_commit> id - bude hash commitu Tento příkaz započne proces rebase . Proces se zastaví a dá nám na výběr co můžeme udělat. Většinou pomocí příkazu --amend uděláme změny a následně řekneme procesu rebase , že může pokračovat. Proces by mohl vypadat nějak takhle: $ git commit --amend $ git rebase --continue 3. Změna několika, libovolně starých commitů Pro změnu několika commitů najednou se používá tzv. interaktivní rebase . Tento typ rebase se zapíná pomocí příkazu: $ git rebase -i nebo $ git rebase --interactive Během rebase několika commitů najednou máme možnost si vybrat z několika možností jak takové commity spojit dohromady. Reword nebo zkráceně ‘r' - zastaví proces rebase a nechá Vás přepsat konkrétní commit message Squash nebo kráceně ‘s' - během procesu rebase , všechny commity označené pomocí s se sloučí s posledním commitem. Proces rebase se pozastaví a budeme vyzvání k přepsání posledního commitu. Fixup nebo zkráceně ‘f' - se chová podobně jako squash . Narozdíl od squashe , tak fixup nepozastaví proces rebase k otevření textového editoru. commit meassage zůstane stejná jako je poslední v posledním commitu pouze se tomuto poslednímu commitu přilepí commity, které jsme označili písmenem f . commit messages obsažené v commitech, které jsme označili pomocí f jsou zahozeny. drop Kromě spojování commitů, je možné v interaktivním rebase také commity smazat pomocí slovíčka drop nebo d . Smazat commit je také možné pokud před daný commit nedáte žádné specialní slovo. pickup Slovo pickup nebo p znamená, že tento commit chceme zachovat vzít. V interaktivním rebase můžeme také přehazovat pořadí jednotlivých commitů , jak v historii gitu půjdou za sebou. 4. Git rebase Pro lepší pochopení celého kontextu se nevyhneme detailnímu popsání příkazu git rebase . Na začátek git rebase a git merge jsou v základu stejné příkazi. Oba dva slučují jednu větev do druhé. Ale každý to dělá jinak. Na konci článku je část, která se zabývá přímo srovnáním těchto dvou příkazů. Příkaz git rebase je možné používat ve dvou módech: standardní či manuální mód interaktivní mód (pomocí přepínače -i nebo --interactive ) Nejčastejší použití rebase můžeme vidět, když máme projekt, který je na větvi master . Tento projekt potřebuje vyvinout novou featuru. Pro tyto účely si založíme novou větev feature_branch . Na nové feature budeme pracovat nějaký čas. A v tomto čase, kdy mi budeme pracovat na feature, kterou jsme dostali za úkol, bude zbytek týmu pracovat na dalších features projektu. Tím se samozřejmě podoba větve master změní od podoby, z které jsme vytvořili novou větev feature_branch . Tento proces můžeme vidět na diagramu níže: a - b - c - g - h (master) \\ d - e (feature_branch) Novou větev feature_branch jsme vytvořili když větev master měla poslední commit c . Nyní když bych chtěl mou featuru mergnout tak větev master se posunula o další dva commity g a h . Abychom mohli naši větev pěkně mergnout musíme na ni udělat nejříve udělat rebase . Tedy chceme založit naše další změny na změnách ostatních - \"I want to base my changes on what everybody has already done.\" Užitečné odkazy - další studium Text článku byl čerpán hlavně z těchto zdrojů: https://www.atlassian.com/git/tutorials/rewriting-history https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase https://dev.to/martinbelev/how-to-effectively-use-git-rebase-onto-5b85","tags":"Git","url":"https://nappex.github.io/myblog/git-fix-history","loc":"https://nappex.github.io/myblog/git-fix-history"},{"title":"Git - introduction to basic commands","text":"Co je Git ? Git je nástroj na správu revizí vašich souborů, které určíte, že mají být sledovány Gitem. To znamená, že Git zaznamenává veškeré změny, které byly v souboru provedeny od jeho založení až po jeho dokončení. Můžeme se v historii díky gitu i vracet k úpravě, kterou jsme udělali třeba před půlrokem a tuto revizi si vytáhnout a pokračovat jiným směrem. Jinými slovy měli jsme-li nějaký soubor, který jsme nějak upravovali, ale usoudili jsme, že úpravy v posledním měsíci nebylo to pravé a zjistli jsme, že jsme se vydali slepou uličkou, můžeme se vrátit k verzi, kterou jsme udělali před měsícem a pokračovat jiným způsobem. Git nedělá nic automaticky je třeba mu vše říct a manuálně popsat co má udělat. Třeba Word, google zaznamenává změny automaticky oproti Gitu. U Gitu je nutné více přemýšlet co verzovat co commitovat apod. Ale pokud postupujete správně velmi pěkně se dá v historii verzí číst. S tím souvisí i online služby jako GitHub nebo GitLab. Tyto služby pouze poskytují na webu naše git repozitáře s jejich historií. Nestarají se o udělání revize apod. Nahráváme tam revize na které se ostatní z týmu mohou podívat. Instalace Git Instalace se liší dle vašeho OS . Instalace Git je velmi pěkně popsána na těchto stránkách: naucse.python.cz Celý Git workshop vč. instalace naleznete také na youtube: www.youtube.com/watch?v=zOWcQezeyIU Stavy souborů v Git 1. Změněn či nesledován (Working directory) V této fázi můžeme naleznout dva typy souboru. Oba dva typy souboru jsou označovány po příkazu git status červenou barvou. První typ je soubor, který je uložen v pracovní složce ale git jej nesleduje a neví o změnách, ke kterým v tomto souboru dochází. Po příkazu git status jsou označovány jako untracked files. Druhým typem je soubor, který sice již byl přidán, následně změněn, commitnutý, ale znova změněn. Tento soubor je nyní registrován jako modified a to červeně. Pokud se nám změny v modified souboru líbí tak soubor znovu pomocí git add přidáme do stage faze odkud jej mužeme commitnout. 2. Připraveno k zapsání (Staged - staging area) To je fáze, takového pre-commitu je to soubor, který si připravuju ke commitu, dělám na něm ještě změny. Až své změny dokončím přejdu ke commit fázi. V této fázi můžeme vzít soubor zpět ze sledování gitem nebo ho dle libosti upravovat, jak se mi zlíbí. Můžeme to také nazvat jako přípravna - prostor, kde připravujeme soubor ke konečné revizi. Soubory, které máme uloženy v fázi staged poznáme také tak, že pokud zavoláme command git status, tak soubory které jsou ve fázi staged jsou zelené a pokud nemáte povoleno color.ui a nemáte tak povoleno barevné výstupy z gitu tak jsou soubory označeny větičkou \"changes to be commited:\" a před každým souborem připravným ke commitu je buď new file nebo modified. V této fázi lze také soubor ze sledování odebrat a to pomocí příkazu git rm --cached <file> , ono i git vám po git status vypíše nápovědu, která vypadá takto use git rm --cached <file>... to unstage. 3. Zapsáno (Committed - git directory, repository) Konečné nevratné zapsání změn do master nebo do vedlejší větve. Tímto potvrzením se zapíší na dobro do historie změn daného souboru. Změny provedené v commit lze zase zpět postup je následující: $ git commit -m \"Something terribly misguided\" $ git reset HEAD~ << edit file s as necessary >> $ git add ... $ git commit -c ORIG_HEAD Základní příkazy git clone <URL> Je něco podobného jako git init s tím, že vytváří repozitář tak, že ho celý stahuje přímo z nějaké internetové služby jako je například. GitHub nebo GitLab. Po zadání takového příkazu se nám z online lužby stáhne celý repozitář i s historií gitu. <URL> bude většinou vypadat jako https://github.com/username_1/nazev_clonovaneho_repozitare git init Vytvoří z prázdné složky ve vašem počítači nebo složky projektu repozitář. Jinými slovy můžeme říct také, že pomocí tohoto příkazu řekneme gitu, že v tomto adresáři chcem spravovat verze souborů. Repozitář - je složka, v které sledujeme provedené změny v souborech. git add Pokud chceme aby git sledoval změny provedené v daném souboru musíme tento soubor pomocí tohoto příkazu zaregistrovat/přidat, čímž říkáme gite chceme ať tento soubor sleduješ, změny v něm provedené. Tedy z untracked files vytvoříme staged files Příklady použití: 1. přidání konkrétních souborů git add <jmeno souboru1> <jmeno souboru2> 2. přidání všech dostupných souborů git add --all zkráceně git add -A nebo git add . git commit Tento příkaz udělá novou revizi, nový bod v historii. Zapíše do historie nově provedené změny v souboru. Součástí každého commitu by mělo být stručně popsáno jaké změny jsme provedli. Po tomto příkazu se nám otevře textový editor pro příkazovou řádku (nano, vim, notepad). V tomto editoru napíšeme změny, které jsme udělali a proč jsme takové změny udělali a text uložíme. Příkaz můžeme napsat pouze jako git commit, v tomto případě se nám zapíší veškeré změny ve všech souborech. Je také možné napsat: git commit <jmeno souboru1> <jmeno souboru2> v tomto případě se provede commit pouze na vypsané soubory. Jak správně napsat zprávu do commit: Nejdříve napíšu na první řádek jasně stručně co jsem udělal. Potom vynechám řádek a rozepíšu se podrobněji o změnách a proč jsem je udělal. To proto že při ukázání více comittů se zobrazuje vždy první řádek. První řádek půjde vždy všude vidět. Ukázka zprávy v commitu: Přidal jsem funkci sečti a také funkci validátor která funkci sečti doplňuje. Tyto dvě funkce jsem přidal proto a proto a také díky nim je kód kratší a program je rychlejší. Níže jsou další zdroje \"jak správně napsat commit\" : GitHub - Writing good commit messages git status Zeptáme se gitu co si myslí o aktutálním stavu v současném repozitáři. Dává informaci, které soubory jsou sledovány, které naopak nikoliv. Nebo které soubory byly modifikovány a čekají na commit. Pokud nám git status vypíše: * On branch master * * nothing to commit , working tree clean * První řádek znamená, že jsme na větvi (branch) hlavní linie (master) Druhý řádek znamená, že od posledního commitu nedošlo k žádným změnám ve sledovaných souborech. Nejsou dostupné žádné změny ke commitu. git diff Ukazuje změnu v souboru modified, oproti souboru, který byl už commitnutý. To znamená, že se jedná o soubor, který byl změněn, ale nebyl ještě přidán pomocí git add do fáze stage. git show Nám ukáže poslední revizi, kterou jsme provedli pomocí git commit . Pokud na konci revize vidíte dvojtečku : tak je revize delší než je příkazová řádka schopna vypsat. Pomocí šipek nebo PageDown, PageUp můžeme v celé revizi scrollovat. Pokud chceme z vypsání revize odejít, musíme zmáčknout klávesu s písmenem q . Below you can see on picture result from command git show . Every commit has its own unique code - it is second line on picture. There are also information abou Author which you set with git config . Information about date when commit was done. After Date is text which you write when you were commiting file. Zbytek je sekce diff v které je popsána samotná změna celé revize zaregostrované pod jejím kódem. Řádky které byly přidány do daného souboru tak začínají symbolem \"+\", naopak řádky které byly odebrány mají na začátku znaménko \"-\". Filosofie gitu je kontrolovat změny vždy v jednom řádku. stačí tedy, že v řádku změníte jedno písmeno a git to vyhodnotí, že celý řádek byl změněn. Konrétní revizi lze ukázat také pomocí git show <kód revize> git log Mi ukáže seznam všech revizí, které byly v daném repozitáři provedeny. Na začátku je vždy nejposlednější revize. git stash Odložení dělání věci, kterou chceme na chvíli pozastavit. Musíme opravit jinou chybu msuíme jít dělat něco jiného. Není ješte ready na commit. Vrácení se k odložené práci se vrátíme pomocit git stash apply . Když jsme si odložili více práce tak pomocí git stash list si je všechny vypíšeme. A zjistíme pod kterým číslem se nachází práce na které chceme zrovna pokračovat. gitk --all Rozjede grafické okno gitu. Není moc hezké, ale je velmi funčkní. git reset (např. git reset README.md ) Změnu, kterou jsme v souboru provedli se smaže. Jak uložit změny bez \"commitu\" Čas od času se vyskytne následující situace: Pracujete na nějaké feature pro daný projekt. Pro tuto featuru jste si vytvořili novou větev a udělali jste první nástřel změn, o kteých máte pocit, že by mohli být těmi správnými k dosažení cíle. Teď nastane okamžik, kdy práci musíte ale přerušit a dodělat nějaký detail na jiné branchi. Ovšem Vaše změny na současné branchi nejsou vůbec dodělané ve fázi, že byste je chtěli commitnout. Jedná se o nějaký nástřel Vašich myšlenek, ale vůbec nevíte jestli je to správná cesta. Nechcete změny commitnout, ale zároveň o změny ani nechcete přijít. Chcete na ně po dokončení prioritnějšího úkolu navázat. Potřebujete je jen dočasně někam uložit. První vás napadne změny by se mohli uložit automaticky… Takhle ale Git nefunguje ve chvíli, kdy se budete chtít přepnout z větve, kde jsou provedené změny, ale nejsou commitnuté, měli byste dostat nějakou takovouhle hlášku: $ git switch <different_branch> error: Your local changes to the following files would be overwritten by checkout: <some_file_1.py> <some_file_2.py> Please commit your changes or stash them before you switch branches. Aborting Když si hlášku pozorně celou přečtete, tak uvidíte, že Git Vám na konci radí, že pokud chcete přepnout ze současné větve na jinou tak udělejte commit nebo stash . Commit už známe a git stash je přesně to co hledáme. Tento příkaz nám umožní své změny uložit do gitu a později se k nim vrátit. Použití git stash Tento příkaz vám umožní uložit si změny, které jsou v danou chvíli ve staged nebo v unstaged . Po příkazu git stash můžete přepínat větve commitovat další změny apod. Je nutné si dát, ale pozor, že toto uložení je pouze ve vašem lokální repozitáři. Pokud provedete git push stashed files se na server neposílají. V praxi použití příkazu git stash může vypadata nějak takto: $ git status On branch master Changes to be committed: new file: hello.py Changes not staged for commit: modified: index.html $ git stash Saved working directory and index state WIP on master: 3022f53 our new homepage HEAD is now at 3022f53 our new homepage $ git status On branch master nothing to commit, working tree clean Pokud budete chtít změny uložené v gitu zase aplikovat do svého projektu použijete git stash pop nebo git stash apply git stash pop Tento příkaz aplikuje změny ve stash do vašeho projektu a zároveň tyto změny ze stash vymaže. $ git status On branch master nothing to commit, working tree clean $ git stash pop On branch master Changes to be committed: new file: hello.py Changes not staged for commit: modified: index.html Dropped refs/stash@ { 0 } ( 32b3aa1d123dfe6d57b3c3cc2c45cbf3f456cc6a ) git stash apply Tento příkaz aplikuje změny ve stash do vašeho projektu (větve), ale změny uložené ve stash zachová. To se může hodit například pokud chcete stash aplikovat do více větví. $ git stash apply On branch master Changes to be committed: new file: hello.py Changes not staged for commit: modified: index.html POZOR : Git defaultně neukládá do stash untracked nebo ignore soubory. Větvení v Gitu git branch Vypíše seznam všech větví, které jsou v projektu vytvořené git branch <nazev_nove_vetve> Vytvoření nové větve s názvem \"nazev_nove_vetve\". Nazev nové větve se píše bez mezer. git branch --delete <nazev_vetve> zkráceně git branch -d <nazev_vetve> Vymazání konkrétní větve se jménem v projektu git branch -D <nazev_vetve> Vymazání konkrétní větve se jménem , která nebyla mergnutá nebo pushnutá a musíme ji vymazat tzv. force delete Výše uvedené příklady vymažou větev pouze na lokálním gitu. Pokud současně kód nahrávate např. na GitHub tak větev na Githubu zůstane i když jste po smazání větve na local gitu udělali git push origin master . Pro smazání větve také na remote musíte zadat další kód: git push <remote> --delete <nazev_remote_vetve> zkráceně git push <remote> -d <nazev_remote_vetve> Vymaže větev také na remote. Původní příkazy: 1. git checkout <nazev_vetve> Přepnutí se ze současné větve na novou větev s názvem \"nazev_vetve\" 2. git checkout <jmeno_souboru> Zahození změn v souboru se jmenem \"jmeno_souboru\" Nové příkazy: 1. git switch <nazev_vetve> Přepnutí se ze současné větve na novou větev s názvem \"nazev_vetve\" 2. git restore <jmeno_souboru> Zahození změn v souboru se jmenem \"jmeno_souboru\" Příkaz git checkout může být trochu matoucí. Jelikož od verze gitu tuším 2.24 v gitu přibyly další dva příkazy a to git switch a git restore . Původně před touto implementací dvou nových příkazů se příkaz git checkout používal pro dvě naprosto rozdílné činnosti a to na za 1. změnu větve - a to v případě, kdy jste git checkout dali jméno větve nebo 2. zahazovaly se změny v souboru - to v případě, kdy jste příkazu git checkout dali jméno souboru. Tyto dvě operace spolu vůbec nesouvisí a tak bylo dlouhá léta příkaz git checkout trochu matoucí na co se vlastně používá. Z tohoto důvodu se nově zavedli dva rozdílné příkazy pro tyto dvě operace ať je situace zcela jasnější. Tedy, nově se pro změnu větve používá git switch <jmeno_vetve> a pro zahození změn v souboru se používá git restore <jmeno_souboru> . Tyto nové příkazy mají také i novou implementaci a proto úkonům jako je změna větve dochází u git switch trochu jinak než u git checkout . Tak samo u git checkout a git restore . Toho si můžete všimnout když pomocí nových příkazů budete chtítí udělat to co jste v minulosti dělali pomocí git checkout , tak že výsledek může být malinko odlišný. git merge <nazev_vetve> Sloučí větev na které jsme zrovna přihlášeni (nejčastěji to bude větev master) s větví, kterou zadáme v příkazu jako \"nazev_vetve\". Remote příkazy Remote znamená vzdálené repozitáře na Githubu např. Jak už jste viděli někde origin , tak to je jméno jednoho z remote, konkrétně origin je jméno repozitáře odkud jsme prováděli git clone . Když si založíme na svém počítači repozitář pomocí git init , tak nebudeme mít nastavené žádné remote. origin znamená také základní remote, v kterém jsou všechna data, která jsme si stáhli pomocí git clone . Je to zdroj našeho stáhnutého repozitáře z online služeb jako je GitHub. git remote Vypíše všechny remote uložené v projektu git remote --verbose nebo git remote -v Vypsání seznamu všech remote v tz. modu verbose , tedy ukecanější podrobnější výpis všech remote git remote add <jmeno_remote> <url_repo_na_github> Způsob ja přidat další remote do vašeho seznamu remote. <jmeno–remote> bude nejčastěji váš nick nebo nick člověka na githubu, který má stejný repo. Jedná se o jednoduchý název pro remote, aby ste jej mohli snadno v seznamu a při použití příkázů identifikovat. Přece jen je sadnější psát jméno remote než celé url od remote. git remote remove <jmeno_remote> Smaže ze seznamu uložených remote deifonovaný Můžeme použít také zkrácený příkaz, který se používal ve starších verzích gitu git remote rm <jmeno_remote> git fetch <remote> <branch> Fetch znamená, že mohu aktualizovat svůj repozitář např. z remote origin , tedy změny, které ve svém repozitáři nemám a došlo k nim od jiných uživatelů. Příklad udělal jsem si git clone <URL> a projektu jsem se půl roku nevěnoval. Teď bych na něm chtěl začít pracovat, ale můj stažený repozitář v mém počítači (local) je odlišný od repozitáře uložený na GitHubu, jelikož ostatní na tomto projektu pracovali. Musím si tedy svůj lokální repozitář updatovat s repozitářem na Githubu abych dělal na aktuální verzi. Ale pozor fetch stáhne pouze nová data, ale nezakomponuje je do Vaší větve pomocí merge . To je hlavní rozdíl od git pull . Fetch nezakomponuje změny do našeho local branch . git pull <remote> <branch> Vyjadřuje jednoduchá rovnice –> git pull = git fetch + git merge git push <remote> <branch> Je opakem fetch , uděláme novou změnu a chceme ji zakomponovat do origin . Pošleme tuto změnu pomocí git push origin master naši vytvořenou změnu. Autor projektu usoudí jestli se mu naše změna líbí či ne a zda ji tedy zakomponuje do svého projektu. Abychom to mohli poslat do originu který není náš, musíme nejdříve na githubu forknout originální projekt. Poslat naši zmenu na náš forknutý repo pomocí git push <jmeno_remote> <jmeno_branch> . Následně si na GitHubu najdou tlačítko New pull request . Pokud tedy budu chtít pushnout své změny na origin musím to udělat přes GitHub přes svůj forknutý repo. Postup by byl tedy git clone <origin-url> , potom na github fork origin projektu, poté udělám změny u sebe na localu pošlu je na svůj github a poté zmáčknu New pull request . pull request: žádost o začlenění. pošlu autorovi prosbu o začlenění mých změn. Nastavuji na kterou větev to posílám na originu jakou větev svou chci začlenit. Ignorování souborů Způsob ignorování souborů rozdělujeme do třech skupin, dle toho jaký typ souboru chceme ignorovat. 1. Ignorování souborů a složek, které automaticky vytváří pouze náš počítač dle OS Jedná se o ignorování souborů či složek, které se vytváří pouze na našem počítači. Jedná se o soubory, které vytváří náš operační systém nebo náš editor textu (např. cache/, .vscode/). Tyto soubory se nám vytvoří automaticky při spuštění jekéhokoliv projektu a bylo by otravné je pokaždé znova nastavovat k ignoraci. Pro ignorování takových souborů je třeba si vytvořit svůj vlastní soubor do kterého napíšeme, které soubory či složky se mají ignorovat. git config --global core.excludesfile /home/user_1/Documents/<název_vaseho_souboru> Tímto příkazem nastavíte v gitu, který máte nainstalovaný na PC cestu k souboru, v kterém je zapsáno, které soubory a složky má git ignorovat a nevšímat si jich. 2. Soubory, které vytváří Váš pythonní program Jedná se o soubory, které jsou vytvořeny při běhu skriptu. Například nějaké csv, nějaký obrázek či graf. 3. Soubory, v kterých jsou napsány citlivé údaje Jedná se o soubory, v kterých jsou napsána hesla, API klíče nebo citlivé údaje ohledně soukromí. Tyto soubory se týkají většinou pouze jednoho specifického projektu a proto se nepíšou do souboru, který globálně ignoruje specifikované soubory a složky, jak bylo uvedeno výše. Mohou být totiž pro každý projekt jiné. Tyto soubory se specifikují v inicializované složce .git v daném projektu. Tedy v gitu, který sleduje pouze tento projekt. Cesta k tomuto souboru je: .git / info / exclude Další nástroje, které se používají společně s gitem tig Je to nástroj jehož název je git naopak. slouží ke seznamu všech commitů. Něco jako git log , ale daleko podrobnější. Použité zdroje - další studium Web z kterého čerpám nejvíce: naucse.python.cz/course/pyladies/sessions/foss/ Velmi povedená stránka na základní Git příkazy atlassian.com - git","tags":"Git","url":"https://nappex.github.io/myblog/git-introduction","loc":"https://nappex.github.io/myblog/git-introduction"}]};